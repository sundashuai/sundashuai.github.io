<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SUN&#39;S BLOG</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-05-27T12:04:48.426Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>孙大帅</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>类与对象、封装、构造方法</title>
    <link href="http://yoursite.com/2018/05/27/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E3%80%81%E5%B0%81%E8%A3%85%E3%80%81%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2018/05/27/类与对象、封装、构造方法/</id>
    <published>2018-05-27T11:58:46.493Z</published>
    <updated>2018-05-27T12:04:48.426Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p>类：一组相关<strong>属性</strong>和<strong>行为</strong>的集合，是一类事物的描述，是<strong>抽象</strong>的</p><p>对象：是类的一个实例，是<strong>具体</strong>的</p><h2 id="对象内存（栈内存、堆内存、方法区）"><a href="#对象内存（栈内存、堆内存、方法区）" class="headerlink" title="对象内存（栈内存、堆内存、方法区）"></a>对象内存（栈内存、堆内存、方法区）</h2><ol><li><p>在方法区中分配空间加载.class文件</p></li><li><p>main方法压栈，创建新对象（如：People p=new People();），在main方法中创建新的对象p来保存地址值；在堆内存中开辟空间，保存People类的属性和<strong>方法地址</strong>，将这块空间的地制值传递给main方法中的变量p</p></li><li><p>通过对象去修改属性，调用方法，只需要通过p中变量地址到堆内存找到那块空间修改属性，再通过<strong>方法地址</strong>到方法区查找方法，并调用</p></li><li><p>找到方法后压栈，执行结束后出栈</p><p><strong>方法地址：实现方法的共享</strong></p></li></ol><h2 id="成员变量-amp-局部变量"><a href="#成员变量-amp-局部变量" class="headerlink" title="成员变量&amp;局部变量"></a>成员变量&amp;局部变量</h2><p>在方法中，如果使用了成员变量与局部变量同名的变量，符合就近原则，直接使用的是局部变量</p><ol><li>定义的位置不同    <ul><li>成员变量：类中方法外    </li><li>局部变量：方法中</li></ul></li><li>作用范围不同 <ul><li>成员变量：整个类中都能用 </li><li>局部变量：只能在定义该变量的方法中</li></ul></li><li>处于内存的位置不同 <ul><li>成员变量：在堆内存中</li><li>局部变量：在栈内存</li></ul></li><li>默认值不同<ul><li>成员变量：有默认值的</li><li>局部变量：没有默认值</li></ul></li><li>生命周期不同<ul><li>成员变量：随着对象的出现而出现，随着对象的销毁而销毁</li><li>局部变量：随着方法的出现而出现，随着方法的销毁而销毁</li></ul></li></ol><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>为了代码安全性</p><ol><li>使用private修饰符</li><li>提供对应属性的getXXX+setXXX方法</li></ol><h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2><p>方法中的形参就是局部变量</p><p>使用this：this.成员变量名，表示的是当前对象的成员变量，可以用来区分成员变量和局部变量</p><p>this：哪个对象调用该方法，那么这个this就表示该对象；可以用来表示调用当前非静态方法的对象的地址值</p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>通过new创建构造方法，创建对象并对属性赋值</p><p>有参构造方法：创建对象并赋值指定的值</p><p>无参构造方法：创建对象并赋值默认初始化值</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;类和对象&quot;&gt;&lt;a href=&quot;#类和对象&quot; class=&quot;headerlink&quot; title=&quot;类和对象&quot;&gt;&lt;/a&gt;类和对象&lt;/h2&gt;&lt;p&gt;类：一组相关&lt;strong&gt;属性&lt;/strong&gt;和&lt;strong&gt;行为&lt;/strong&gt;的集合，是一类事物的描述，是&lt;st
      
    
    </summary>
    
      <category term="基础" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="JavaSE" scheme="http://yoursite.com/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>数组</title>
    <link href="http://yoursite.com/2018/05/27/%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2018/05/27/数组/</id>
    <published>2018-05-27T11:58:44.931Z</published>
    <updated>2018-05-27T11:59:44.623Z</updated>
    
    <content type="html"><![CDATA[<h2 id="java内存分配（简）"><a href="#java内存分配（简）" class="headerlink" title="java内存分配（简）"></a>java内存分配（简）</h2><ul><li><p>栈内存（方法栈）：所有方法在栈内存开辟空间，方法内变量在其空间中再开辟空间；方法中的变量随方法出现而出现，随方法销毁而销毁。</p></li><li><p>堆内存：通过new关键字创建的内容，在堆内存开辟空间都有默认值，</p><p>byte、short、int、long：0</p><p>char：字符空格</p><p>boolean：false</p><p>double：0.0</p><p>引用数据类型：null</p></li><li><p>方法区：字节码文件保存在方法区中</p></li><li><p>寄存器：给cpu使用</p></li><li><p>本地方法栈：jvm在使用操作系统功能时使用</p></li></ul><h2 id="数组异常"><a href="#数组异常" class="headerlink" title="数组异常"></a>数组异常</h2><ul><li><p>ArrayIndexOutOfBoundersException：数组索引越界异常</p><p>注意：数组长度固定，最大索引值是array.length-1</p></li><li><p>NullPointerException：空指针异常</p></li></ul><p><strong>数组作为方法参数传递的是数组地址</strong></p><p><strong>数组作为返回值类型返回的是数组地址</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;java内存分配（简）&quot;&gt;&lt;a href=&quot;#java内存分配（简）&quot; class=&quot;headerlink&quot; title=&quot;java内存分配（简）&quot;&gt;&lt;/a&gt;java内存分配（简）&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;栈内存（方法栈）：所有方法在栈内存开辟空间，方法内
      
    
    </summary>
    
      <category term="基础" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="JavaSE" scheme="http://yoursite.com/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>流程控制、方法</title>
    <link href="http://yoursite.com/2018/05/23/--%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E3%80%81%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2018/05/23/--流程控制、方法/</id>
    <published>2018-05-23T07:50:56.924Z</published>
    <updated>2018-05-24T07:22:34.840Z</updated>
    
    <content type="html"><![CDATA[<h2 id="switch语句case穿透"><a href="#switch语句case穿透" class="headerlink" title="switch语句case穿透"></a>switch语句case穿透</h2><ol><li>switch(表达式)：进行选择判断的数据类型只能是byte、short、int、char、menu、String</li><li>case穿透：匹配一个case后，执行语句体，没有break继续向下执行，直到遇到break跳出或switch语句结束</li></ol><h2 id="三种循环区别"><a href="#三种循环区别" class="headerlink" title="三种循环区别"></a>三种循环区别</h2><ol><li>循环条件都不满足时，只有do-while一定会执行一次</li><li>for循环的变量定义在for内部，for循环以外不能用</li><li>while和do-while的循环变量可以一直使用</li></ol><h2 id="break-amp-continue"><a href="#break-amp-continue" class="headerlink" title="break&amp;continue"></a>break&amp;continue</h2><ul><li>break：结束switch语句、结束循环（<strong>只能在循环与switch中使用</strong>）</li><li>continue：跳过本次循环，继续下一次循环</li></ul><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ol><li>明确返回值类型</li><li>明确参数列表</li><li>方法在执行时必须压栈到栈内存中，在栈内存中jvm只执行内存栈顶的方法</li><li>定义在类中方法体外</li><li>return：结束方法，跟是否返回方法的调用处无关，只要方法结束一定返回方法调用处；一个方法可以有多个return，但只有一个return被调用。</li></ol><h2 id="方法调用三种方式"><a href="#方法调用三种方式" class="headerlink" title="方法调用三种方式"></a>方法调用三种方式</h2><ul><li>直接调用：方法名(参数列表)</li><li>赋值调用：数据类型 变量名=方法名(参数列表)</li><li>打印输出：System.out.println(方法名(参数列表))</li></ul><p><strong>直接调用可以调用任意方法，赋值调用和打印输出只能调用有返回值的方法</strong></p><h2 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h2><ol><li>同一个类中</li><li>同一个方法名</li><li>参数列表不同：参数列表的个数，数据类型，参数的顺序（<strong>与修饰符和返回值类型无关</strong>）</li></ol><p>作用：只要记忆一个方法，就可以实现对应的功能</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;switch语句case穿透&quot;&gt;&lt;a href=&quot;#switch语句case穿透&quot; class=&quot;headerlink&quot; title=&quot;switch语句case穿透&quot;&gt;&lt;/a&gt;switch语句case穿透&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;switch(表达式)：进行选择
      
    
    </summary>
    
      <category term="基础" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="JavaSE" scheme="http://yoursite.com/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>编译运行、数据类型</title>
    <link href="http://yoursite.com/2018/05/21/--%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://yoursite.com/2018/05/21/--编译运行、数据类型/</id>
    <published>2018-05-21T13:43:33.986Z</published>
    <updated>2018-05-22T09:02:48.992Z</updated>
    
    <content type="html"><![CDATA[<h2 id="java开发环境"><a href="#java开发环境" class="headerlink" title="java开发环境"></a>java开发环境</h2><ol><li>jvm：支持java程序运行的程序，实现java的跨平台，jvm不跨</li><li>jre：jvm+jvm运行核心类库</li><li>jdk：jre+java开发包</li></ol><h2 id="编译和运行"><a href="#编译和运行" class="headerlink" title="编译和运行"></a>编译和运行</h2><ul><li>编译：javac.exe启动编译器，将源文件（.java）编译为字节码文件（.class）</li><li>运行：java.exe启动解释器，将.class文件翻译为机器码文件，放入jvm运行</li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ol><li><p>基本数据类型：</p><p>整数型：byte（1）-128——127</p><p>​          short（2）</p><p>​          int（4）<strong>默认</strong>   </p><p>​              long（8）</p><p>浮点型：float：（4）</p><p>​              double（8）<strong>默认</strong></p><p> 字符型：char（2）</p><p>布尔型：boolean（1）</p></li><li><p>引用数据类型：类，数组，接口</p></li></ol><h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><p>转换顺序由小转大：byte、short、char—-&gt;int—-&gt;float—-&gt;double</p><p>强转由大转小：将前面没有意义的字节数去掉，小数点的强转将小数点后面数去掉</p><p>字符的转换：ASCII码：0（48）、A（65）、a（97）</p><h2 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h2><p>数据类型 变量名=表达式1?表达式2:表达式3；</p><p>数据类型与表达式2:表达式3必须一致</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;java开发环境&quot;&gt;&lt;a href=&quot;#java开发环境&quot; class=&quot;headerlink&quot; title=&quot;java开发环境&quot;&gt;&lt;/a&gt;java开发环境&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;jvm：支持java程序运行的程序，实现java的跨平台，jvm不跨&lt;/li&gt;

      
    
    </summary>
    
      <category term="基础" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="JavaSE" scheme="http://yoursite.com/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>JSP简介</title>
    <link href="http://yoursite.com/2018/04/08/jsp%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2018/04/08/jsp简介/</id>
    <published>2018-04-08T11:36:11.556Z</published>
    <updated>2018-04-08T11:44:16.128Z</updated>
    
    <content type="html"><![CDATA[<h2 id="jsp运行原理"><a href="#jsp运行原理" class="headerlink" title="jsp运行原理"></a>jsp运行原理</h2><p>　　jsp实质就是servlet（jsp文件转换servlet文件(.java)编译class文件(.class)执行servlet实例），第一次被访问时会被web容器翻译成servlet再执行。</p><h2 id="jsp三大指令"><a href="#jsp三大指令" class="headerlink" title="jsp三大指令"></a>jsp三大指令</h2><p>1、page指令属性最多，默认就行<br>2、include指令：将一个jsp页面包含到另一个jsp页面<br>　　格式：&lt;%@ include file=”被包含的文件地址”%&gt;<br>3、taglib指令：引入标签库（jstl）<br>　　格式：&lt;%@ taglib uri=”标签库地址” prefix=”前缀”%&gt;</p><h2 id="jsp内置9大隐式对象"><a href="#jsp内置9大隐式对象" class="headerlink" title="jsp内置9大隐式对象"></a><strong>jsp内置9大隐式对象</strong></h2><p><strong>out：用于页面输出，out.write()</strong><br>request：得到用户请求信息<br>response：服务器向客户端的回应信息<br>config：服务器配置<br>session：保存用户的信息<br>application：所有用户共享信息<br>page：当前页面转换后的servlet类的实例<br><strong>pageContext：jsp的页面容器（域对象）</strong><br>exception：异常，在错误页面起作用</p><h2 id="4大域总结"><a href="#4大域总结" class="headerlink" title="4大域总结"></a><strong>4大域总结</strong></h2><p><strong>page域：当前jsp页面范围<br>request域：一次请求<br>session域：一次会话<br>application域：整个web应用</strong></p><p>findAttribute(String name)——<strong>依次从pageContext域，request域，session域，application域中获取属性，获取完将不再向下获取</strong>。</p><p>通过pageContext可获得其他八大隐式对象</p><h2 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h2><p>　　嵌入jsp页面内部，代替jsp页面编写，最主要作用从域中取数据<br>　　jsp脚本：&lt;%=request.getAttribute(name)%&gt;<br>　　EL表达式：${requestScorp.name}</p><hr><p>EL获得pageContext域中的值：<code>${pageScope.key}</code><br>EL获得request域中的值：<code>${requestScope.key}</code><br>EL获得session域中的值：<code>${sessionScopre.key}</code><br>EL获得application域中的值：<code>${applicationScope.key}</code></p><h2 id="EL内置11个对象"><a href="#EL内置11个对象" class="headerlink" title="EL内置11个对象"></a><strong>EL内置11个对象</strong></h2><p>　　作用域：pageScope（page域）、requestScope（request作用域）、sessionScope（session域）、applicationScope（application域）<br>　　请求参数：param（获得一个参数）、paramValues（获得一组参数）<br>　　请求头：header（获得一个请求头）、headerValues（获得一组请求头）<br>　　JSP上下文象：pageContext<br>　　全局初始化参数：initParam<br>　　cookie：cookie</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;jsp运行原理&quot;&gt;&lt;a href=&quot;#jsp运行原理&quot; class=&quot;headerlink&quot; title=&quot;jsp运行原理&quot;&gt;&lt;/a&gt;jsp运行原理&lt;/h2&gt;&lt;p&gt;　　jsp实质就是servlet（jsp文件转换servlet文件(.java)编译class文件(
      
    
    </summary>
    
      <category term="JavaWeb" scheme="http://yoursite.com/categories/JavaWeb/"/>
    
    
      <category term="JavaWeb" scheme="http://yoursite.com/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>Cookie&amp;Session</title>
    <link href="http://yoursite.com/2018/03/25/Cookie&amp;Session/"/>
    <id>http://yoursite.com/2018/03/25/Cookie&amp;Session/</id>
    <published>2018-03-25T08:59:34.572Z</published>
    <updated>2018-03-25T09:38:41.087Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>　　cookie是将数据存储到客户端。<br>　　服务器端向客户端发送一个cookie：<br>　　1、创建cookie：<br>　　<code>Cookie cookie=new Cookie(name,value);</code><br>　　<code>cookie.setMaxAge(秒);</code><br>　　 <code>cookie.setPath();</code><br>　　2、发送cookie：<br>　　<code>response.addCookie(Cookie cookie);</code></p><hr><p>　　服务器端接受客户端携带的Cookie：<br>　  <code>Cookie[] cookies=request.getCookies();</code><br>　<code>for(Cookie cookie:cookies){</code><br>　　　　<code>if(cookie.getName().equal(cookieName)){</code><br>　　　　　<code>String　cookieValue=cookie.getValue();</code><br>　　　<code>}</code><br>　<code>}</code></p><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>　　在服务端为每个客户端创建一块自己的内存空间，客户端携带一个标识ID去寻找自己的内存空间。<br>　　1、获得session对象：<br>　　<code>request.getSession();</code><br>　　2、向session中存取数据(域对象)：<br>　　<code>session.setAttribute(String name,Object obj);</code><br>　　<code>session.getAttribute(String name);</code><br>　　<code>session.removeAttribute(String name);</code><br>　　3、session生命周期<br>　　创建：第一次执行request.getSession();<br>　　销毁：服务器关闭、session失效、手动session.invalidate();<br>　　作用范围：默认一次会话中</p><p>　　</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Cookie&quot;&gt;&lt;a href=&quot;#Cookie&quot; class=&quot;headerlink&quot; title=&quot;Cookie&quot;&gt;&lt;/a&gt;Cookie&lt;/h2&gt;&lt;p&gt;　　cookie是将数据存储到客户端。&lt;br&gt;　　服务器端向客户端发送一个cookie：&lt;br&gt;　　1、创建
      
    
    </summary>
    
      <category term="JavaWeb" scheme="http://yoursite.com/categories/JavaWeb/"/>
    
    
      <category term="JavaWeb" scheme="http://yoursite.com/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>Response&amp;Request</title>
    <link href="http://yoursite.com/2018/03/25/response&amp;request/"/>
    <id>http://yoursite.com/2018/03/25/response&amp;request/</id>
    <published>2018-03-25T08:19:34.513Z</published>
    <updated>2018-03-25T09:38:32.615Z</updated>
    
    <content type="html"><![CDATA[<h2 id="运行过程"><a href="#运行过程" class="headerlink" title="运行过程"></a>运行过程</h2><p>　　客户端发送http请求，tomcat服务器接收请求并解析，将请求信息封装成request对象，并创建一个response对象。创建servlet对象，调用service方法，tomcat去response缓冲区获取设置内容，组成http响应，客户端解析显示页面。</p><h2 id="response解决中文乱码"><a href="#response解决中文乱码" class="headerlink" title="response解决中文乱码"></a>response解决中文乱码</h2><p>　　response.setContentType(“text/html;charset=UTF-8”);</p><h2 id="request解决中文乱码"><a href="#request解决中文乱码" class="headerlink" title="request解决中文乱码"></a>request解决中文乱码</h2><p>　　解决post提交：request.setCharacterEncoding(“UTF-8”);<br>　　解决get提交：parameter=new String(parmater.getbytes(“iso-8859-1”),”UTF-8”);</p><h2 id="request的一些功能"><a href="#request的一些功能" class="headerlink" title="request的一些功能"></a>request的一些功能</h2><p>　　是域对象，访问时创建，响应结束销毁，作用范围在一次请求中；String getParameter(String name)获得请求参数。　　</p><h2 id="转发（forward）与重定向（redirect）"><a href="#转发（forward）与重定向（redirect）" class="headerlink" title="转发（forward）与重定向（redirect）"></a>转发（forward）与重定向（redirect）</h2><p>　　重定向两次请求，转发一次。重定向地址栏变化，转发不变。重定向可以访问外部网站（客户端行为）重新发出请求，无request传递；转发是在内部访问（服务器行为）中间传递的是自己容器内的request。转发性能优于重定向。<br>　　转发：request.getRequestDispatcher(转发地址).forward(req,resp);<br>　　重定向：response.sendRedirect(地址);　　</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;运行过程&quot;&gt;&lt;a href=&quot;#运行过程&quot; class=&quot;headerlink&quot; title=&quot;运行过程&quot;&gt;&lt;/a&gt;运行过程&lt;/h2&gt;&lt;p&gt;　　客户端发送http请求，tomcat服务器接收请求并解析，将请求信息封装成request对象，并创建一个response
      
    
    </summary>
    
      <category term="JavaWeb" scheme="http://yoursite.com/categories/JavaWeb/"/>
    
    
      <category term="JavaWeb" scheme="http://yoursite.com/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb核心之Servlet</title>
    <link href="http://yoursite.com/2018/03/22/--Servlet%E7%AE%80%E4%BB%8B--/"/>
    <id>http://yoursite.com/2018/03/22/--Servlet简介--/</id>
    <published>2018-03-22T15:16:50.628Z</published>
    <updated>2018-05-22T09:00:30.822Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><p>　　Servlet运行在服务器的Java小程序，是sun公司提供的一套规范（接口），用来处理客户端请求、响应给浏览器的动态资源。实质就java代码，通过java的API动态的向客户端输出内容。<br>　　servlet规范包含三个技术点：<br>　　(1) <strong>servlet技术</strong><br>　　(2) filter技术——过滤器<br>　　(3) listener技术——监听器</p><h2 id="Servlet实现"><a href="#Servlet实现" class="headerlink" title="Servlet实现"></a>Servlet实现</h2><p> 　　实现步骤：<br>　　(1) 创建类继承HttpServlet<br>　　(2) 覆盖doGet和doPost方法<br>　　(3) 在web.xml中进行servlet配置</p><h2 id="Servlet的生命周期"><a href="#Servlet的生命周期" class="headerlink" title="Servlet的生命周期"></a>Servlet的生命周期</h2><p>　　(1) init(ServletConfig config)，servlet对象创建时执行<br>　　(2) service(ServletRequest request,ServletResponse response),<strong>每次请求都会执行</strong><br>　　(3) destory(),servlet销毁时执行</p><h2 id="ServletContext对象"><a href="#ServletContext对象" class="headerlink" title="ServletContext对象"></a>ServletContext对象</h2><p> 　　ServletContext代表是一个web应用的环境（上下文）对象，内部封装的是该web应用信息，<strong>该对象一个web应用只有一个</strong>，一个web应用有多个servlet对象。<br>　　 ServletContext对象的生命周期：该web应用被加载（服务器启动或发布web应用）时创建；web应用被卸载（服务器关闭，移除该web应用）时销毁。</p><h2 id="ServletContext是一个域对象"><a href="#ServletContext是一个域对象" class="headerlink" title="ServletContext是一个域对象"></a>ServletContext是一个域对象</h2><p>　　存储数据的区域就是域对象，域对象的通用方法：<br>　　　<em>setAttribute(String name,Object obj);　　　</em>getAttribute(String name);<br>　　　*removeAttribute(String name);<br>　　ServletContext域对象作用范围：整个web应用</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Servlet&quot;&gt;&lt;a href=&quot;#Servlet&quot; class=&quot;headerlink&quot; title=&quot;Servlet&quot;&gt;&lt;/a&gt;Servlet&lt;/h2&gt;&lt;p&gt;　　Servlet运行在服务器的Java小程序，是sun公司提供的一套规范（接口），用来处理客户端请
      
    
    </summary>
    
      <category term="JavaWeb" scheme="http://yoursite.com/categories/JavaWeb/"/>
    
    
      <category term="JavaWeb" scheme="http://yoursite.com/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>代码实例</title>
    <link href="http://yoursite.com/2018/03/21/HelloWorld/"/>
    <id>http://yoursite.com/2018/03/21/HelloWorld/</id>
    <published>2018-03-21T09:20:00.668Z</published>
    <updated>2018-03-25T09:38:24.444Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h2><p>代码示例：</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class helloworld</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String []args)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;Hello world!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;HelloWorld&quot;&gt;&lt;a href=&quot;#HelloWorld&quot; class=&quot;headerlink&quot; title=&quot;HelloWorld&quot;&gt;&lt;/a&gt;HelloWorld&lt;/h2&gt;&lt;p&gt;代码示例：&lt;/p&gt;
&lt;hr&gt;
&lt;figure class=&quot;highligh
      
    
    </summary>
    
      <category term="代码" scheme="http://yoursite.com/categories/%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="代码" scheme="http://yoursite.com/tags/%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
</feed>
