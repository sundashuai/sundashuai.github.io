<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SUN&#39;S BLOG</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-06-26T14:04:27.309Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>孙大帅</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>转换流、序列化流</title>
    <link href="http://yoursite.com/2018/06/26/--%E8%BD%AC%E6%8D%A2%E6%B5%81%E3%80%81%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81/"/>
    <id>http://yoursite.com/2018/06/26/--转换流、序列化流/</id>
    <published>2018-06-26T14:05:03.005Z</published>
    <updated>2018-06-26T14:04:27.309Z</updated>
    
    <content type="html"><![CDATA[<h2 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h2><ul><li><p>InputStreamReader是转换流，可以指定编码进行读取，<strong>是字节通向字符的桥梁</strong>。</p></li><li><p>OutputStreamWriter是转换流，可以指定编码进行写入，<strong>是字符通向字节的桥梁</strong>。</p></li></ul><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><p><code>InputStreamReader(InputStream in)</code>：是使用平台默认的编码方式进行读取</p></li><li><p><code>InputStreamReader(InputStream in, String charsetName)</code>：使用指定的编码进行读取，charsetName是编码方式。</p></li><li><p><code>OutputStreamWriter(OutputStream out)</code>：是使用平台默认的编码方式进行写入</p></li><li><code>OutputStreamWriter(OutputStream out,String charsetName)</code>：使用指定的编码进行写入，charsetName是编码方式。</li></ul><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><ol><li>创建转换流；</li><li>调用方法，进行读取或写入；</li><li>释放资源。</li></ol><h2 id="序列化流"><a href="#序列化流" class="headerlink" title="序列化流"></a>序列化流</h2><ul><li>ObjectOutputStream是序列化流，可以将java程序中的对象写入到文件中。</li></ul><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>ObjectOutputStream(OutputStream out)</code>：需要传递一个字节输出流。</li></ul><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li>创建序列化流对象；</li><li>调用方法，写对象；</li><li>关流。</li></ol><h3 id="写对象的方法"><a href="#写对象的方法" class="headerlink" title="写对象的方法"></a>写对象的方法</h3><ul><li><code>void writeObject(Object obj)</code>：向文件中写对象。</li></ul><h2 id="反序列化流"><a href="#反序列化流" class="headerlink" title="反序列化流"></a>反序列化流</h2><ul><li>ObjectInputStream是反序列化流，可以将文件中的对象读取到java程序中。</li></ul><h3 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>ObjectInputStream(InputStream in)</code>：传递一个字节输入流。</li></ul><h3 id="使用步骤-1"><a href="#使用步骤-1" class="headerlink" title="使用步骤"></a>使用步骤</h3><ol><li>创建ObjectInputStream对象。</li><li>调用方法，读取对象</li><li>释放资源。</li></ol><h3 id="读取对象的方法"><a href="#读取对象的方法" class="headerlink" title="读取对象的方法"></a>读取对象的方法</h3><ul><li><code>Object readObject()</code>：从文件中读取对象。</li></ul><p>注意：假如读取的时候，要读取的对象的类已经不存在了，就会报错 ClassNotFoundException。<br>要写入到文件的对象，一定要实现序列化接口（Serializable接口）。<br>被static修饰的成员不能被序列化，被static修饰的成员属于类不属于对象。<br>如果希望某个成员变量不会写入到文件，并且也不希望使用static关键字，可以使用一个关键字transient ，意思是瞬态，被transient修饰的成员不能被序列化。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;转换流&quot;&gt;&lt;a href=&quot;#转换流&quot; class=&quot;headerlink&quot; title=&quot;转换流&quot;&gt;&lt;/a&gt;转换流&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;InputStreamReader是转换流，可以指定编码进行读取，&lt;strong&gt;是字节通向字符的桥梁&lt;/stro
      
    
    </summary>
    
      <category term="基础" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="JavaSE" scheme="http://yoursite.com/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>字节流、字符流</title>
    <link href="http://yoursite.com/2018/06/26/--%E5%AD%97%E8%8A%82%E6%B5%81%E3%80%81%E5%AD%97%E7%AC%A6%E6%B5%81/"/>
    <id>http://yoursite.com/2018/06/26/--字节流、字符流/</id>
    <published>2018-06-26T14:05:00.458Z</published>
    <updated>2018-06-26T13:39:10.054Z</updated>
    
    <content type="html"><![CDATA[<h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><h3 id="字节输出流OutputStream"><a href="#字节输出流OutputStream" class="headerlink" title="字节输出流OutputStream"></a>字节输出流OutputStream</h3><ul><li>OutputStream是所有字节输出流的顶层父类，是一个抽象类，如果用，使用子类<strong>FileOutputStream</strong>。</li></ul><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><ul><li><p><code>FileOutputStream(File file)</code>：参数是一个File类型的文件。</p></li><li><p><code>FileOutputStream(String name)</code>：参数是一个字符串类型的文件路径。</p></li><li><p><code>FileOutputStream(File file, boolean append)</code><br><code>FileOutputStream(String name, boolean append)</code><br>可以传递第二个参数，如果第二个参数是true表示要在原来文件的基础上进行续写</p><h4 id="写入方法"><a href="#写入方法" class="headerlink" title="写入方法"></a>写入方法</h4></li><li><p><code>void write(int b)</code>：向文件中写入一个字节。</p></li><li><code>void write(byte[] b)</code>：向文件中写入一个字节数组。</li><li><code>void write(byte[] b, int off, int len)</code>：向文件中写入一个字节数组的一部分，off表示开始位置，len表示写几个。</li><li><code>void close()</code>：释放资源，关流。</li></ul><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol><li>创建一个字节输出流对象，绑定一个目的地；</li><li>调用write方法，向文件中写入数据；</li><li>释放资源；</li></ol><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>在java中字符是2个字节，但是如果这个字符在ASCII码范围内，那么他在操作系统中只占一个字节。中文在文件中的大小是多出1个字节，所以调用write方法一次写一个字节不能写中文。</p><h3 id="字节输入流InputStream"><a href="#字节输入流InputStream" class="headerlink" title="字节输入流InputStream"></a>字节输入流InputStream</h3><ul><li>InputStream是所有字节输入流的顶层父类，是一个抽象类。如果用，使用子类<strong>FileInputStream</strong>。</li></ul><h4 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h4><ul><li><code>FileInputStream(File file)</code>：需要传递一个File类型的文件。</li><li><code>FileInputStream(String name)</code>：传递一个字符串类型的文件路径。</li></ul><h4 id="读取方法"><a href="#读取方法" class="headerlink" title="读取方法"></a>读取方法</h4><ul><li><code>int read()</code>：读取一个字节并返回，如果读取结束返回-1。</li><li><code>int read(byte[] b)</code>：读取数据到字节数组中，返回的是读取到的有效个数。</li></ul><h4 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h4><ol><li>创建一个字节输入流用来读取，要绑定一个数据源；</li><li>调用read方法，读取数据；</li><li>释放资源。</li></ol><h4 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h4><p>读取中文会把一个汉字拆开，会有乱码。</p><h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><h3 id="字符输出流Writer"><a href="#字符输出流Writer" class="headerlink" title="字符输出流Writer"></a>字符输出流Writer</h3><ul><li>Writer是字符输出流的顶层父类，是一个抽象类，如果用，使用子类<strong>FileWriter</strong>。</li></ul><h4 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h4><ul><li><code>FileWriter(File file)</code>：传递一个File类型的文件。</li><li><code>FileWriter(String fileName)</code>：传递一个String类型的文件路径。</li></ul><h4 id="写入方法-1"><a href="#写入方法-1" class="headerlink" title="写入方法"></a>写入方法</h4><ul><li><p><code>void write(String str)</code>：写入一个字符串。<br><code>void write(String str, int off, int len)</code>：写入字符串的一部分。<br><code>void write(int c)</code>：写入一个字符。<br><code>void write(char[] cbuf)</code>：写入一个字符数组。<br><code>void write(char[] cbuf, int off, int len)</code>：写入字符数组的一部分。</p></li><li><p><code>void flush()</code>：将内存缓冲区中的数据刷新到文件中，字符输出流写完后一定要刷新。</p></li><li><p><code>void close()</code>：释放资源。</p></li></ul><h4 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤"></a>步骤</h4><ol><li>创建字符输出流对象；</li><li>调用write方法写入；</li><li>刷新（仅仅是做刷新操作，流在刷新之后还能使用）；</li><li>释放资源（关流之前会自动刷新，关闭之后不能使用）。</li></ol><h3 id="字符输入流Reader"><a href="#字符输入流Reader" class="headerlink" title="字符输入流Reader"></a>字符输入流Reader</h3><ul><li>Reader是所有字符输入流的顶层父类，是一个抽象类，如果用，使用子类<strong>FileReader</strong>。字符流是以字符为单位进行读写，所以可以操作中文，因为一个中文就是一个字符。</li></ul><h4 id="构造方法-3"><a href="#构造方法-3" class="headerlink" title="构造方法"></a>构造方法</h4><ul><li><code>FileReader(File file)</code>：传递一个File类型的文件。</li><li><code>FileReader(String fileName)</code>：传递一个String类型的文件路径。</li></ul><h4 id="读取方法-1"><a href="#读取方法-1" class="headerlink" title="读取方法"></a>读取方法</h4><p><code>int read()</code>：一次读取一个字符并返回，结束返回-1。<br><code>int read(char[] cbuf)</code>：读取数据到字符数组中，并且返回读取到的有效个数，读取结束返回-1。</p><h4 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤"></a>步骤</h4><ol><li>创建字符输入流对象；</li><li>调用read方法读取，用变量接读取到的字符，不是-1就读取到内容；</li><li>释放资源。</li></ol><h2 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h2><h3 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h3><ul><li><code>BufferedOutputStream</code>：字节输出缓冲流，用来写。</li><li><code>BufferedInputStream</code>：字节输入缓冲流，用来读。</li></ul><h4 id="构造方法-4"><a href="#构造方法-4" class="headerlink" title="构造方法"></a>构造方法</h4><ul><li><p><code>BufferedOutputStream(OutputStream out)</code>：需要传递一个字节输出流。</p></li><li><p><code>BufferedInputStream(InputStream in)</code>：需要传递一个字节输入流。</p></li></ul><h4 id="步骤-4"><a href="#步骤-4" class="headerlink" title="步骤"></a>步骤</h4><ol><li>创建缓冲流对象；</li><li>调用方法，读或者写（读写的方法和FileOutputStream和FileInputStream一模一样）；</li><li>释放资源。</li></ol><h3 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h3><ul><li><code>BufferedWriter</code>：字符输出缓冲流，用来写。</li><li><code>BufferedReader</code>：字符输入缓冲流，用来读。</li></ul><h4 id="构造方法-5"><a href="#构造方法-5" class="headerlink" title="构造方法"></a>构造方法</h4><ul><li><code>BufferedWriter(Writer out)</code>：参数需要传递一个字符输出流（FileWriter）。</li><li><code>BufferedReader(Reader in)</code>：参数需要传递一个字节输入流（FileReader）。</li></ul><h4 id="步骤-5"><a href="#步骤-5" class="headerlink" title="步骤"></a>步骤</h4><ol><li>创建流对象。</li><li>调用方法，读或者写（读写的方法和FileReader和FileWriter一模一样）；</li><li>释放资源。</li></ol><h4 id="特有方法"><a href="#特有方法" class="headerlink" title="特有方法"></a>特有方法</h4><ul><li>BufferedWriter有一个特有的方法，void newLine()：实现一个跨平台的换行符</li><li>BufferedReader有一个特有的方法，String readLine()：一次读取一行数据，并返回读取到的这行， 如果读取结束返回null</li></ul><h2 id="属性集"><a href="#属性集" class="headerlink" title="属性集"></a>属性集</h2><h3 id="Properties类"><a href="#Properties类" class="headerlink" title="Properties类"></a>Properties类</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol><li>Properties是Hashtable的子类，并且实现了Map接口，所以Properties是双列集合，拥有Map集合所有功能。</li><li>没有泛型，键和值全部都是字符串。</li><li>这个集合支持对文件的操作，可以从文件中读取键值对。</li></ol><h4 id="构造方法-6"><a href="#构造方法-6" class="headerlink" title="构造方法"></a>构造方法</h4><ul><li><code>Properties()</code>：空参构造</li></ul><h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><ul><li><code>Object setProperty(String key, String value)</code>：向Properties集合添加键值对。</li><li><code>String getProperty(String key)</code>：根据key获取value。</li><li><code>Set &lt;String&gt; stringPropertyNames()</code>：获取存放所有key的集合。</li><li><code>void load(InputStream inStream)</code>：传递一个字节输入流。<br><code>void load(Reader reader)</code>：传递一个字符输入流。<br>使用步骤：<ol><li>创建Properties集合对象；</li><li>创建一个输入流对象，绑定一个数据源；</li><li>调用Properties的load方法，将文件中的键值对加载到Properties集合中。</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;字节流&quot;&gt;&lt;a href=&quot;#字节流&quot; class=&quot;headerlink&quot; title=&quot;字节流&quot;&gt;&lt;/a&gt;字节流&lt;/h2&gt;&lt;h3 id=&quot;字节输出流OutputStream&quot;&gt;&lt;a href=&quot;#字节输出流OutputStream&quot; class=&quot;header
      
    
    </summary>
    
      <category term="基础" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="JavaSE" scheme="http://yoursite.com/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>File类</title>
    <link href="http://yoursite.com/2018/06/26/--File%E7%B1%BB/"/>
    <id>http://yoursite.com/2018/06/26/--File类/</id>
    <published>2018-06-26T14:04:58.333Z</published>
    <updated>2018-06-26T02:51:31.455Z</updated>
    
    <content type="html"><![CDATA[<h2 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h2><p>File类可以表示计算机中的文件或者文件夹。</p><ul><li>绝对路径：是一个从盘符开始的路径，是一个非常详细的路径。</li><li>相对路径：不是从盘符开始的路径，相对路径相对的是某一个位置，在idea中，相对路径指的是当前项目下的东西。</li></ul><h3 id="File中的获取方法"><a href="#File中的获取方法" class="headerlink" title="File中的获取方法"></a>File中的获取方法</h3><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><ul><li><code>File(String pathname)</code>：根据一个文件或者文件夹的路径构造一个File对象。</li><li><code>File(String parent, String child)</code>：根据父路径和子路径组合构造一个File对象。</li></ul><h4 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h4><ul><li><code>String getAbsolutePath()</code>：获取当前File对象的绝对路径</li><li><code>String getPath()</code>： 获取File对象表示的路径</li><li><code>String getName()</code>：获取File对象表示的文件或者文件夹的名字</li><li><code>long length()</code>：获取文件的字节数大小。如果通过文件夹调用这个方法，得到的是一个不确定的值。</li></ul><h4 id="判断方法"><a href="#判断方法" class="headerlink" title="判断方法"></a>判断方法</h4><ul><li><code>public boolean exists()</code>：判断File对象所表示的文件或者文件夹是否存在</li><li><code>boolean isDirectory()</code>：判断当前File对象表示的是否是一个文件夹</li><li><code>boolean isFile()</code>：判断当前File对象表示的是否是一个文件</li></ul><h4 id="创建方法"><a href="#创建方法" class="headerlink" title="创建方法"></a>创建方法</h4><ul><li><code>boolean createNewFile()</code>：创建一个文件，如果文件已经存在，则创建失败。</li><li><code>boolean mkdir()</code>：创建一个文件夹，如果文件夹已经存在则创建失败，不存在则创建。</li><li><code>boolean mkdirs()</code>：创建多级目录（文件夹）如果上级目录不存在，会一起创建上级目录。</li></ul><h4 id="删除方法"><a href="#删除方法" class="headerlink" title="删除方法"></a>删除方法</h4><ul><li><code>boolean delete()</code>： 删除File对象所表示的文件或者文件夹，如果不存在删除失败。如果要删除的是一个文件夹，只能删除空文件夹，如果这个文件夹里面有内容，是不能删除的。delete方法不走回收站，需谨慎。</li></ul><h4 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h4><ul><li><code>String[] list()</code>：可以获取到指定目录中的所有文件或文件夹，获取到的真正是文件或者文件夹的名字。</li><li><code>File[] listFiles​()</code>：<strong>获取到指定目录下的所有文件或者文件夹，返回值是File数组</strong>。</li></ul><h4 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h4><ul><li>File[] listFiles(FileFilter filter)：FileFilter表示过滤器，是一个接口。</li></ul><p>过滤器的使用步骤：</p><ol><li>创建一个类，实现FileFilter接口。</li><li>重写accept方法，定义过滤的规则。如果希望某个东西留下，就通过某种条件返回true，否则就返回false。</li><li>在测试类中创建File对象，并且调用listFiles方法，传递一个过滤器。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;File类&quot;&gt;&lt;a href=&quot;#File类&quot; class=&quot;headerlink&quot; title=&quot;File类&quot;&gt;&lt;/a&gt;File类&lt;/h2&gt;&lt;p&gt;File类可以表示计算机中的文件或者文件夹。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;绝对路径：是一个从盘符开始的路径，是一个非常
      
    
    </summary>
    
      <category term="基础" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="JavaSE" scheme="http://yoursite.com/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>Lambda表达式</title>
    <link href="http://yoursite.com/2018/06/26/--Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/06/26/--Lambda表达式/</id>
    <published>2018-06-26T02:21:36.618Z</published>
    <updated>2018-06-26T02:21:14.724Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h2><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(参数列表) -&gt; &#123;</span><br><span class="line">     方法体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Lambda省略格式"><a href="#Lambda省略格式" class="headerlink" title="Lambda省略格式"></a>Lambda省略格式</h3><ol><li>可以省略参数的数据类型。</li><li>如果参数只有一个，可以省略小括号。</li><li>大括号中一条语句，可以省略大括号，reutrn，以及分号。</li></ol><h3 id="Lambda表达式的前提"><a href="#Lambda表达式的前提" class="headerlink" title="Lambda表达式的前提"></a>Lambda表达式的前提</h3><ol><li>方法参数一定要是一个接口，不能是抽象类</li><li>这个接口中有且仅要有一个需被重写的抽象方法。(函数式接口)</li><li>支持上下文推断（参数要是接口类型）</li></ol><h3 id="匿名内部类不能和Lambda表达式完全替换"><a href="#匿名内部类不能和Lambda表达式完全替换" class="headerlink" title="匿名内部类不能和Lambda表达式完全替换"></a>匿名内部类不能和Lambda表达式完全替换</h3><ol><li>匿名内部类作为父类的不仅仅可以是接口，也可以是抽象类或者普通类，而Lambda表达式一定要是函数式接口。</li><li>匿名内部类可以重写多个方法，而Lambda表达式只能是一个。</li></ol><h3 id="匿名内部类和Lambda表达式原理机制完全不同"><a href="#匿名内部类和Lambda表达式原理机制完全不同" class="headerlink" title="匿名内部类和Lambda表达式原理机制完全不同"></a>匿名内部类和Lambda表达式原理机制完全不同</h3><ol><li>匿名内部类在执行的时候会生成外部类$1.class 这样的字节码文件，但是Lambda表达式不会。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Lambda&quot;&gt;&lt;a href=&quot;#Lambda&quot; class=&quot;headerlink&quot; title=&quot;Lambda&quot;&gt;&lt;/a&gt;Lambda&lt;/h2&gt;&lt;h3 id=&quot;格式&quot;&gt;&lt;a href=&quot;#格式&quot; class=&quot;headerlink&quot; title=&quot;格式&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="基础" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="JavaSE" scheme="http://yoursite.com/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>线程、同步、线程池</title>
    <link href="http://yoursite.com/2018/06/24/--%E7%BA%BF%E7%A8%8B%E3%80%81%E5%90%8C%E6%AD%A5%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://yoursite.com/2018/06/24/--线程、同步、线程池/</id>
    <published>2018-06-24T11:02:38.620Z</published>
    <updated>2018-06-26T02:12:02.827Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>构造方法：</p><ul><li><code>public Thread()</code> ：分配一个新的线程对象。</li><li><code>public Thread(String name)</code>：分配一个指定名字的新的线程对象。</li><li><code>public Thread(Runnable target)</code>：分配一个带有指定目标新的线程对象。</li><li><code>public Thread(Runnable target,String name)</code>：分配一个带有指定目标新的线程对象并指定名字。</li></ul><p>常用方法：</p><ul><li><code>public String getName()</code> ：获取当前线程名称。</li><li><code>public void start()</code> ：导致此线程开始执行； Java虚拟机调用此线程的run方法。</li><li><code>public void run()</code> ：此线程要执行的任务在此处定义代码。</li><li><code>public static void sleep(long millis)</code>：使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。</li><li><code>public static Thread currentThread()</code>：返回对当前正在执行的线程对象的引用。</li></ul><h2 id="多线程的内存"><a href="#多线程的内存" class="headerlink" title="多线程的内存"></a>多线程的内存</h2><ul><li>每个线程都有自己的栈区，每个栈区调用的方法都会进入到自己的栈区，<strong>栈内存是线程私有的</strong></li><li><strong>多线程共享一个堆内存</strong></li></ul><h2 id="多线程实现方式"><a href="#多线程实现方式" class="headerlink" title="多线程实现方式"></a>多线程实现方式</h2><h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><ol><li>定义类，继承Thread</li><li>重写run方法。</li><li>测试类中创建Thread子类对象</li><li>调用start方法。</li></ol><h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><ol><li>定义类，去实现Runnable接口。</li><li>重写run方法，也是要在run方法中定义线程要执行的任务。</li><li>在测试类中创建Runnable接口的实现类对象。</li><li>创建一个线程Thread类的对象，并且把Runnable接口的实现类对象传递过去。</li><li>调用Thread的start方法。</li></ol><h3 id="实现Runnable接口的优势"><a href="#实现Runnable接口的优势" class="headerlink" title="实现Runnable接口的优势"></a>实现Runnable接口的优势</h3><ol><li>解决了java中类与类之间只能单继承的局限性。</li><li>Runnable接口里面只有一个run方法，没有getName，sleep，currentThread…里面的功能更加的纯粹，只需要关注线程要执行的任务就可以了，这样更加符合单一职责原则。</li><li>解耦。</li><li>可以更加方便的实现多个线程间的数据共享。</li><li>线程池可以传递Runnable接口的实现类对象，但是不能传递Thread的子类对象</li></ol><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><h3 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h3><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(锁对象) &#123;</span><br><span class="line">    <span class="comment">//要同步的内容。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>锁对象就是一个普通的对象，可以是任意对象，没有特殊的含义，只是做一个标记。</li><li>synchronized代码块的作用： 只有持有锁的线程才能够进入到同步代码块中。</li></ul><h3 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h3><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">    修饰符 <span class="keyword">synchronized</span> 返回值类型 方法名(参数列表) &#123;</span><br><span class="line">        方法体;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>synchronized修饰方法，相当于把整个方法体都加了同步代码块。</li></ul><h3 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a>Lock接口</h3><p>在jdk1.5之后，多了一个包，叫做java.util.concurrent，提供了很多对多线程操作的类和接口，其中有一个接口，叫做Lock，可以手动的释放锁以及获取锁。<br>void lock()： 手动的获取一个锁<br>void unlock()： 手动的释放锁<br>Lock 是一个接口，如果要用，需要使用实现类ReentrantLock。</p><h3 id="安全效率比较"><a href="#安全效率比较" class="headerlink" title="安全效率比较"></a>安全效率比较</h3><p>StringBuilder：线程不安全，效率高</p><p>StringBuffer：线程安全，效率低</p><p>ArrayList，LinkedList：线程不安全的，效率高</p><p>Vector集合（淘汰了）：线程安全的，效率低</p><p>HashMap： 线程不安全，效率高</p><p>Hashtable：线程安全，效率低</p><p>ConcurrentHashMap：线程安全，效率高</p><h2 id="线程的六种状态"><a href="#线程的六种状态" class="headerlink" title="线程的六种状态"></a>线程的六种状态</h2><ol><li><p>NEW （新建）</p><p>当一个线程仅仅被创建（new Thread() 或者new Thread子类()）那么这个线程就是出于NEW（新建）状态</p></li><li><p>RUNNABLE （执行）</p><p>一个线程处于执行状态，当调用start方法后，这个线程会变成这个状态</p></li><li><p>BLOCKED（受阻塞）</p><p>当一个线程等待其他线程释放锁时，那么这个线程就属于受阻塞的状态。</p></li><li><p>WAITING（无限等待）</p><p>当一个线程一直去等着某个东西，那么这个线程所处于的状态就是无限等待。wait() 无限等待的方法，除非有另一个线程唤醒自己。</p></li><li><p>TIMED_WAITING（计时等待）</p><p>当一个线程去有一定时间的等着，那么线程就处于计时等待。比如sleep(mills) 这个方法，会等着这个时间结束然后去运行。</p></li><li><p>TERMINATED（退出）</p><p>当该线程的run方法结束或者调用stop方法强制结束，这这个线程就会变成退出</p></li></ol><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><ul><li>线程池的顶层接口： Executor， 只负责运行线程。常用的子接口： ExecutorService</li><li>线程池的工具类： <strong>Executors 这个工具类可以获取一个线程池对象</strong>。</li></ul><p>工具类里面的方法<br><code>static ExecutorService newFixedThreadPool​(int nThreads)</code>：直接获取到一个定长的线程池</p><p>实现步骤：</p><ol><li>通过线程池工具类获取到一个线程池对象。</li><li>创建Runnable并重写run方法。</li><li>调用线程池对象的submit，并传递Runnable实现类对象，表示使用线程池中的某个线程去执行该任务。submit(Runnable task)：参数是一个Runnable接口类型</li><li><p>销毁线程池（一般不做）shutdown()：销毁线程池</p><p>扩展：</p></li></ol><p>newCachedThreadPool()：获取一个长度可变的线程池。如果线程不够用了，该线程池会自己创建新的线程，如果闲置的线程比较多，这个线程池也会自动回收线程</p><p>newFixedThreadPool(int nThreads)：定长的线程池，多余的任务会在队列中等待。</p><p>newScheduledThreadPool(int corePoolSize)：可周期性执行任务的线程池</p><p>newSingleThreadExecutor()：一个单线程的线程池，可以指定线程的执行顺序。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;线程&quot;&gt;&lt;a href=&quot;#线程&quot; class=&quot;headerlink&quot; title=&quot;线程&quot;&gt;&lt;/a&gt;线程&lt;/h2&gt;&lt;p&gt;构造方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;public Thread()&lt;/code&gt; ：分配一个新的线程对象。&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="基础" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="JavaSE" scheme="http://yoursite.com/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>异常</title>
    <link href="http://yoursite.com/2018/06/24/--%E5%BC%82%E5%B8%B8/"/>
    <id>http://yoursite.com/2018/06/24/--异常/</id>
    <published>2018-06-24T11:02:31.323Z</published>
    <updated>2018-06-19T02:21:58.312Z</updated>
    
    <content type="html"><![CDATA[<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="运行时和编译时异常"><a href="#运行时和编译时异常" class="headerlink" title="运行时和编译时异常"></a>运行时和编译时异常</h3><ul><li>运行时异常： 当一个方法内抛出运行时异常时，你可以处理（throws，try…catch），也可以不处理。</li><li>编译时异常： 当一个方法内抛出编译时异常，必须要处理（要么抛，要么try…catch).</li></ul><h3 id="throw关键字"><a href="#throw关键字" class="headerlink" title="throw关键字"></a>throw关键字</h3><ul><li>想要手动抛出一个异常，可以使用throw关键字。格式：throw new 异常类名();</li></ul><h3 id="throws"><a href="#throws" class="headerlink" title="throws"></a>throws</h3><ul><li>进行方法的异常声明。 当一个方法内抛出了编译时异常，则必须要进行异常声明。</li><li>注意：<ol><li>当一个方法内抛出了编译时异常，则必须要进行异常声明。</li><li>当调用了一个使用throws声明的异常方法，那么这个方法要么处理，要么throws声明可能会抛出异常</li><li>如果在一个方法内抛出了多个异常，那么在throws声明的时候需要声明多个或者也可以直接throws他们的父类异常。</li><li>当在一个方法内抛出了运行时异常，那么可以使用throws声明，也可以不使用。<h3 id="try…catch…finally"><a href="#try…catch…finally" class="headerlink" title="try…catch…finally"></a>try…catch…finally</h3></li></ol></li><li>如果希望解决掉异常，而不是把异常往外抛，可以使用try…catch语句。</li><li>如果try中的代码出现了问题，但是catch并没有捕获到，这个异常依然会往外抛。</li><li>如果catch中要捕获的是父类异常，那么可以捕获到他对应的子类异常。</li><li>finally代码一定会执行，用于释放资源</li></ul><h3 id="throwable中常见方法"><a href="#throwable中常见方法" class="headerlink" title="throwable中常见方法"></a>throwable中常见方法</h3><ul><li><code>tring toString()</code>： 返回详细描述</li><li><code>String getMessage()</code>： 返回简单的描述。</li><li><code>void printStackTrace()</code>： 将非常详细的信息打印到控制台。使用的另一个线程打印的。</li></ul><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><ul><li>使用一个类继承体系中的任何一个类<ol><li>如果这个类继承的是RuntimeException或者他下面的子类，那么这个类就是运行时异常。</li><li>如果这个类继承的Exception或者除了RuntimeException之外的其他子类，那么这个类就是编译时异常。</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;异常&quot;&gt;&lt;a href=&quot;#异常&quot; class=&quot;headerlink&quot; title=&quot;异常&quot;&gt;&lt;/a&gt;异常&lt;/h2&gt;&lt;h3 id=&quot;运行时和编译时异常&quot;&gt;&lt;a href=&quot;#运行时和编译时异常&quot; class=&quot;headerlink&quot; title=&quot;运行时和编译时
      
    
    </summary>
    
      <category term="基础" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="JavaSE" scheme="http://yoursite.com/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>Object类、常用API</title>
    <link href="http://yoursite.com/2018/06/15/--Object%E7%B1%BB%E3%80%81%E5%B8%B8%E7%94%A8API/"/>
    <id>http://yoursite.com/2018/06/15/--Object类、常用API/</id>
    <published>2018-06-15T11:47:09.357Z</published>
    <updated>2018-06-15T11:46:52.052Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h2><p>java.lang.Object 类是Java语言中的根类，即所有类的父类 </p><ul><li><p>public String toString() ：返回该对象的字符串表示。</p><p>由于toString方法返回的结果是内存地址，而在开发中，经常需要字符串表现形式，因此也需要<strong>重写</strong>它。</p></li></ul><ul><li><p>public boolean equals(Object obj) ：指示其他某个对象是否与此对象“相等”。</p><p>默认地址比较：没有覆盖重写equals方法，那么默认进行== 运算符的对象地址比较，只要不是同一个对象，结果必然为false.</p><p>对象内容比较：进行对象的内容比较，可以<strong>覆盖重写equals方法</strong></p></li></ul><h2 id="Objects类"><a href="#Objects类" class="headerlink" title="Objects类"></a>Objects类</h2><p>java.util.Objects在JDK7添加了一个Objects工具类</p><ul><li>它由一些静态的实用方法组成，用于计算对象的hashcode、返回对象的字符串表示形式、比较两个对象。</li><li>public static boolean equals(Object a, Object b) ：判断两个对象是否相等。</li></ul><h2 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h2><p>java.util.Date 类 表示特定的瞬间，精确到毫秒。</p><ul><li><p>public Date() ：无参构造，可以自动设置当前系统时间的毫秒时刻</p></li><li><p>public Date(long date) ：指定long类型的构造参数，可以自定义毫秒时刻，</p><p>以表示自从标准基准时间（称为“历元（epoch）”，即<strong>1970年1月1日00:00:00 GMT</strong>）以来的指定毫秒数。</p></li><li><p>tips: 由于我们处于东八区，所以我们的基准时间为1970年1月1日8时0分0秒。</p></li><li><p>常用方法：</p><p>public long getTime() 把日期对象转换成对应的时间毫秒值。</p></li></ul><h2 id="DateFormat类"><a href="#DateFormat类" class="headerlink" title="DateFormat类"></a>DateFormat类</h2><p>java.text.DateFormat 是日期/时间格式化子类的抽象类</p><ul><li><p>DateFormat为抽象类，需要常用的子类java.text.SimpleDateFormat</p></li><li><p>构造方法：</p><p>SimpleDateFormat sdf = new SimpleDateFormat(“yyyy‐MM‐dd”);//创建SimpleDateFormat对象,写日期模式</p></li><li><p>常用格式规则：</p><p>| 标识字母（区分大小写） | 含义   |<br>| :———- | —- |<br>| y           | 年    |<br>| M           | 月    |<br>| d           | 日    |<br>| H           | 时    |<br>| m           | 分    |<br>| s           | 秒    |</p></li><li><p>格式化：Date-&gt;String：public String <strong>format</strong>(Date date)</p><p>解析：String-&gt;Date：public Date <strong>parse</strong>(String source)</p></li></ul><h2 id="Calendar类-日历"><a href="#Calendar类-日历" class="headerlink" title="Calendar类(日历)"></a>Calendar类(日历)</h2><p>java.util.Calendar 是日历类</p><ul><li><p>Calendar类在创建对象时并非直接创建，而是<strong>通过静态方法创建</strong>，返回子类对象</p></li><li><p>Calendar c=Calendar.getInstance() ：创建Calendar对象</p></li><li><p>常用方法：</p><p>public int get(int field) ：返回给定日历字段的值。</p><p>public void set(int field, int value) ：将给定的日历字段设置为给定值。</p><p>public abstract void add(int field, int amount) ：根据日历的规则，为给定的日历字段添加或减去指定的时间量。</p><p>public Date getTime() ：并不是获取毫秒时刻，而是拿到对应的Date对象。</p></li><li><p>在Calendar类中，月份的表示是以0-11代表1-12月。</p></li></ul><h2 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h2><p>java.lang.System 类中提供了大量的<strong>静态</strong>方法</p><ul><li><p>public static long currentTimeMillis()：是获取当前系统时间与1970年01月01日00:00点之间的毫秒差值</p></li><li><p>public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length) ：将<br>数组中指定的数据拷贝到另一个数组中。</p><p>| 参数名称    | 参数类型   | 参数含义       |<br>| ——- | —— | ———- |<br>| src     | Object | 源数组        |<br>| srcPos  | int    | 源数组索引起始位置  |<br>| dest    | Object | 目标数组       |<br>| destPos | int    | 目标数组索引起始位置 |<br>| length  | int    | 复制元素个数     |</p></li></ul><h2 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h2><p>java.lang.StringBuilder可变字符序列</p><ul><li><p>StringBuilder是个字符串的缓冲区，底层是数组，StringBuilder会自动维护数组的扩容</p></li><li><p>构造方法：</p><p>public StringBuilder() ：构造一个空的StringBuilder容器。<br>public StringBuilder(String str) ：构造一个StringBuilder容器，并将字符串添加进去。</p></li><li><p>常用方法：</p><p>public StringBuilder append(…) ：添加任意类型数据的字符串形式，并返回当前对象自身。<br>public String toString() ：将当前StringBuilder对象转换为String对象。</p></li></ul><h2 id="基本类型与字符串之间的转换"><a href="#基本类型与字符串之间的转换" class="headerlink" title="基本类型与字符串之间的转换"></a>基本类型与字符串之间的转换</h2><ul><li><p>基本类型转换String总共有三种方式：</p><ol><li><strong>基本类型直接与””相连接</strong></li><li>使用String的valueOf方法。</li><li>使用包装类对应的toString方法。</li></ol></li><li><p>字符串转基本类型</p><p>直接调用包装类的静态方法就可以了。</p><p>仅以Integer类的静态方法parseXxx为例：Integer.parseInt(String)：转成int类型数字</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Object类&quot;&gt;&lt;a href=&quot;#Object类&quot; class=&quot;headerlink&quot; title=&quot;Object类&quot;&gt;&lt;/a&gt;Object类&lt;/h2&gt;&lt;p&gt;java.lang.Object 类是Java语言中的根类，即所有类的父类 &lt;/p&gt;
&lt;ul&gt;
&lt;l
      
    
    </summary>
    
      <category term="基础" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="JavaSE" scheme="http://yoursite.com/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>List集合、Set集合、可变参数、Collections</title>
    <link href="http://yoursite.com/2018/06/15/--List%E9%9B%86%E5%90%88%E3%80%81Set%E9%9B%86%E5%90%88/"/>
    <id>http://yoursite.com/2018/06/15/--List集合、Set集合/</id>
    <published>2018-06-15T11:47:09.357Z</published>
    <updated>2018-06-15T11:46:59.534Z</updated>
    
    <content type="html"><![CDATA[<h2 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h2><ul><li>list接口是Collection下面的一个子接口</li><li>特点：<strong>存取有序，有索引，可以存重复元素</strong></li><li>常用实现类：<strong>ArrayList（底层是数组，查找快增删慢）</strong>、<strong>LinkedList（底层双向链表，增删快查找慢）</strong></li></ul><h3 id="对索引操作"><a href="#对索引操作" class="headerlink" title="对索引操作"></a>对索引操作</h3><ul><li><code>public void add(int index, E element)</code> ： 将指定的元素，添加到该集合中的指定位置上。</li><li><strong><code>public E get(int index)</code></strong> ：返回集合中指定位置的元素。</li><li><code>public E remove(int index)</code> ：移除列表中指定位置的元素, 返回的是被移除的元素。</li><li><code>public E set(int index, E element)</code> ：用指定元素替换集合中指定位置的元素,返回值的更新前的元素。</li></ul><h3 id="LinkedList独有方法"><a href="#LinkedList独有方法" class="headerlink" title="LinkedList独有方法"></a>LinkedList独有方法</h3><ul><li><code>public void addFirst(E e)</code> ：将指定元素插入此列表的开头。</li><li><code>public void addLast(E e)</code>：将指定元素添加到此列表的结尾。</li><li><code>public E getFirst()</code> ：返回此列表的第一个元素。</li><li><code>public E getLast()</code> ：返回此列表的最后一个元素。</li><li><code>public E removeFirst()</code> ：移除并返回此列表的第一个元素。</li><li><code>public E removeLast()</code> ：移除并返回此列表的最后一个元素。</li><li><code>public E pop()</code>：从此列表所表示的堆栈处弹出一个元素。</li><li><code>public void push(E e)</code>：将元素推入此列表所表示的堆栈。</li><li><code>public boolean isEmpty()</code> ：如果列表不包含元素，则返回true</li></ul><h2 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h2><ul><li>set接口是Collection下面的一个子接口</li><li>特点：<strong>存取无序，无索引，不能存重复元素</strong></li><li>常用实现类：HashSet（底层哈希表：数组+链表+红黑树）、LinkedHashSet<strong>有序</strong>（底层链表和哈希表组合）</li><li><strong>Set集合取出元素</strong>的方式可以采用：<strong>迭代器、增强for</strong>（因无索引）</li></ul><h3 id="HashSet判断唯一性的原理"><a href="#HashSet判断唯一性的原理" class="headerlink" title="HashSet判断唯一性的原理"></a>HashSet判断唯一性的原理</h3><ol><li>先调用hashCode比较哈希值， 如果哈希值不同，肯定不是相同的对象。如果哈希值相同，不一定是相同的对象。</li><li>当对象哈希值相同的情况下，还需要调用equals。如果equals相同，就是同一个对象。如果equals不同，就不是同一个对象。</li></ol><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><ul><li>归并后的才是哈希表，JDK8之前的数组中的每个元素都是链表，JDK8之后，链表长度超过8，就会自动变成红黑树。</li><li>哈希表就是一个数组，数组中每个元素都是链表，HashSet集合中，哈希表默认长度16。</li><li>桶：数组中每个元素（都是链表），放的是归并后的内容。</li><li>哈希冲突：出现在同一个桶内的对象就是哈希冲突。</li><li>加载因子：是一个百分比，默认0.75，当桶的比例超过加载因子，会再哈希（扩容16-&gt;32）。</li></ul><h3 id="哈希值"><a href="#哈希值" class="headerlink" title="哈希值"></a>哈希值</h3><ul><li>其实就是一个int数字， 可以把这个数字（哈希值）看成对象的特征码（不是唯一的标识）。</li><li>Object里面的hashCode方法的哈希值是通过地址值计算出来的。</li><li>自定义哈希值，在子类中重写hashCode就行了；对自定义对象进行去重，<strong>需要重写hashCode和equals方法</strong>。</li></ul><h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(数据类型... 变量名) &#123;</span><br><span class="line">    //方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可变参数位置可以传递任意个参数（0个1个或者多个），这些参数的数据类型必须一致。</li><li>可变参数本质其实是数组，如果在方法内使用可变参，就按照数组的方式去使用就可以了，调用方法的时候也可以传递数组。</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>一个方法最多只能有一个可变参数</li><li>方法的可变参数一定要放在最后一个位置</li><li>可变参数本质是数组，所以不能和数组构成重载</li></ol><h2 id="Collections-集合工具类"><a href="#Collections-集合工具类" class="headerlink" title="Collections 集合工具类"></a>Collections 集合工具类</h2><ul><li><p>public static <t> boolean addAll(Collection<t> c, T… elements) :往集合中添加一些元素。</t></t></p><p>参数c：表示要往哪个集合中添加元素</p><p>参数elements： 要往集合中添加哪些元素</p></li><li><p>public static void shuffle(List&lt;?&gt; list) 打乱顺序 ：打乱集合顺序。</p></li><li><p>public static <t> void sort(List<t> list) ：将集合中元素按照默认规则排序。使用sort排序的集合里面的泛型类，一定要实现一个Comparable接口。实现这个接口的对象具有自然排序的功能，自然排序指的是这个对象本身就具备了排序的功能。</t></t></p></li><li><p>public static <t> void sort(List<t> list，Comparator&lt;? super T&gt; ) ：将集合中元素按照指定规则排序。</t></t></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Comparable：实现这个接口的类具备自然排序的功能。自己就具备了排序的功能。</span><br><span class="line">Comparator：是一个比较器，可以帮助别人排序</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;List集合&quot;&gt;&lt;a href=&quot;#List集合&quot; class=&quot;headerlink&quot; title=&quot;List集合&quot;&gt;&lt;/a&gt;List集合&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;list接口是Collection下面的一个子接口&lt;/li&gt;
&lt;li&gt;特点：&lt;strong&gt;存取
      
    
    </summary>
    
      <category term="基础" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="JavaSE" scheme="http://yoursite.com/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>Map集合</title>
    <link href="http://yoursite.com/2018/06/15/--Map%E9%9B%86%E5%90%88/"/>
    <id>http://yoursite.com/2018/06/15/--Map集合/</id>
    <published>2018-06-15T11:47:09.357Z</published>
    <updated>2018-06-15T11:50:13.375Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h2><ul><li>map属于双列集合，每个元素都是一个键值对</li><li>特点：<strong>键唯一，值可以重复，键和值可以为null</strong></li><li>常用实现类：HashMap（底层数组哈希表）、LinkedHasMap有序（哈希表加链表）</li></ul><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ul><li><code>V put(K key, V value)</code>： 向Map集合中添加键值对。</li><li><code>V get(Object key)</code>： 根据key获取value。</li><li><code>V remove(Object key)</code>： 根据key，直接删除整个的键值对。返回值为被删除掉的值。</li></ul><h3 id="遍历步骤"><a href="#遍历步骤" class="headerlink" title="遍历步骤"></a>遍历步骤</h3><p>第一种：</p><ol><li>调用Map集合keySet方法获取到所有的key，存放于Set集合中；</li><li>遍历Set集合，得到所有的key；</li><li>调用Map集合的get方法，根据key获取value。</li></ol><p>第二种：</p><ol><li>通过Map集合调用entrySet方法，获取到保存所有Entry对象的Set集合。</li><li>遍历Set集合，拿到里面的所有的Entry对象</li><li>调用Entry的getKey和getValue获取键和值。</li></ol><p>总结：如果要存储自定义对象作为key，如果要保证一致性，要重写hashCode和equals方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.9 之后，集合多了of方法，可以直接创建带有少量元素的集合。</span><br><span class="line">注意：</span><br><span class="line">    1. 这个of方法是List，Set，Map接口的静态方法。这些接口的子类并没有实现这个方法</span><br><span class="line">    2. 通过这种方式创建出来的集合是不能修改的，比如不能往这个集合中添加数据</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Map集合&quot;&gt;&lt;a href=&quot;#Map集合&quot; class=&quot;headerlink&quot; title=&quot;Map集合&quot;&gt;&lt;/a&gt;Map集合&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;map属于双列集合，每个元素都是一个键值对&lt;/li&gt;
&lt;li&gt;特点：&lt;strong&gt;键唯一，值可以重复，
      
    
    </summary>
    
      <category term="基础" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="JavaSE" scheme="http://yoursite.com/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>Collection集合、泛型</title>
    <link href="http://yoursite.com/2018/06/15/--Collection%E9%9B%86%E5%90%88%E3%80%81%E6%B3%9B%E5%9E%8B/"/>
    <id>http://yoursite.com/2018/06/15/--Collection集合、泛型/</id>
    <published>2018-06-15T11:46:31.166Z</published>
    <updated>2018-06-15T11:46:00.814Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Collection集合"><a href="#Collection集合" class="headerlink" title="Collection集合"></a>Collection集合</h2><ul><li>单列集合类的根接口</li><li>两个重要子接口：java.util.List（元素有序可重复）和java.util.Set（元素无序不重复）</li></ul><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p><code>boolean add(E e)</code>： 添加元素<br><code>void clear()</code>： 清除所有元素<br><code>boolean contains(Object o)</code>： 判断集合中是否包含指定元素<br><code>boolean isEmpty()</code>： 判断集合中有没有元素，如果没有元素返回true<br><code>boolean remove(Object o)</code>：删除指定的元素<br><code>int size()</code>：集合的大小<br><code>Object[] toArray()</code>：把集合转成一个数组</p><h3 id="遍历集合"><a href="#遍历集合" class="headerlink" title="遍历集合"></a>遍历集合</h3><p>步骤：</p><ol><li>调用iterator方法获取到集合的迭代器。</li><li>判断还有没有元素可以获取hasNext。</li><li>调用next方法获取元素，并且把光标向后移动。</li></ol><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><ul><li>泛型是一种未知的，不确定的数据类型，如果省略，泛型为Object类型</li><li>泛型的好处：省略的强转的代码。将异常从运行时期提前到了编译时期。</li><li>泛型只在编译时期有效，一旦到了运行时期，泛型就会消失（俗称为泛型擦除）</li></ul><p>泛型类、泛型方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在类名后面加上&lt;T&gt;（T可以是任意的字母），这个类就变成了泛型类。</span><br><span class="line">如果想要所有泛型的范围， 可以使用泛型方法。</span><br><span class="line">格式：</span><br><span class="line">修饰符 &lt;泛型&gt; 返回值类型 方法名(参数列表) &#123;&#125;</span><br><span class="line">泛型方法上的泛型，需要等到调用方法的时候才确定。</span><br></pre></td></tr></table></figure><p>泛型接口：</p><pre><code>如果把泛型加在接口名字后面，那么这个接口就是泛型接口泛型接口两种使用方式1. 实现类在实现这个接口的时候，直接把这个泛型确定出来2. 实现类在实现这个接口的时候，可以不确定泛型的类型， 等到使用这个实现类的时候再确定。</code></pre><p>泛型通配符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;?&gt;： ?表示泛型通配符，可以匹配任何类型的泛型。</span><br><span class="line">泛型通配符只能在参数位置被动匹配，不能主动使用。</span><br><span class="line">泛型限定，可以限制泛型通配符? 的类型</span><br><span class="line">    格式</span><br><span class="line">    &lt;? extends A&gt;： 泛型类型只能是A类或者A类的子类。 </span><br><span class="line">    &lt;? super A&gt;： 泛型只能是A类或者A类的父类。     </span><br><span class="line"> 泛型的作用：一般用来对代码结构进行优化，进行重构。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Collection集合&quot;&gt;&lt;a href=&quot;#Collection集合&quot; class=&quot;headerlink&quot; title=&quot;Collection集合&quot;&gt;&lt;/a&gt;Collection集合&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;单列集合类的根接口&lt;/li&gt;
&lt;li&gt;两个重要子
      
    
    </summary>
    
      <category term="基础" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="JavaSE" scheme="http://yoursite.com/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>多态</title>
    <link href="http://yoursite.com/2018/06/12/--%E5%A4%9A%E6%80%81/"/>
    <id>http://yoursite.com/2018/06/12/--多态/</id>
    <published>2018-06-12T12:16:38.667Z</published>
    <updated>2018-06-12T12:16:38.810Z</updated>
    
    <content type="html"><![CDATA[<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><ul><li>多态是基于继承的，没有继承就没有多态；多态体现：父类引用指向子类对象。</li><li>多态的格式：父类类型 对象名 = new 子类类型();       </li><li>接口中多态格式：接口类型 对象名 = new 该接口的实现类类型()</li></ul><h3 id="成员变量的访问特点"><a href="#成员变量的访问特点" class="headerlink" title="成员变量的访问特点"></a>成员变量的访问特点</h3><ol><li>直接通过对象访问变量，对象创建语句中，=左边是谁，就优先使用谁的成员变量，如果没有则向上找</li><li>通过对象调用成员方法，间接访问成员变量，方法属于谁，就优先使用谁的成员变量，如果没有则向上找</li></ol><h3 id="成员方法的访问特点"><a href="#成员方法的访问特点" class="headerlink" title="成员方法的访问特点"></a>成员方法的访问特点</h3><ol><li><strong>编译看左边，运行看右边</strong>(在多态里面，方法的调用只能调用父类拥有的方法，而子类中独有的方法是不能调用)</li><li>通过对象直接访问成员方法时，new 后是谁，就优先使用谁的成员方法，没有则向上找</li></ol><h3 id="对象的向上向下转型"><a href="#对象的向上向下转型" class="headerlink" title="对象的向上向下转型"></a>对象的向上向下转型</h3><ol><li>向上转型：就是将子类赋值给父类</li><li>多态的向下转型时，一定要是对应的类型才能转换（强转），否则会报错java.lang.ClassCastException（类型转换异常）</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;多态&quot;&gt;&lt;a href=&quot;#多态&quot; class=&quot;headerlink&quot; title=&quot;多态&quot;&gt;&lt;/a&gt;多态&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;多态是基于继承的，没有继承就没有多态；多态体现：父类引用指向子类对象。&lt;/li&gt;
&lt;li&gt;多态的格式：父类类型 对象名 = ne
      
    
    </summary>
    
      <category term="基础" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="JavaSE" scheme="http://yoursite.com/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>接口</title>
    <link href="http://yoursite.com/2018/06/12/--%E6%8E%A5%E5%8F%A3/"/>
    <id>http://yoursite.com/2018/06/12/--接口/</id>
    <published>2018-06-12T11:45:46.132Z</published>
    <updated>2018-06-12T11:45:46.259Z</updated>
    
    <content type="html"><![CDATA[<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><ul><li>接口中的内容特点：<ol><li>抽象方法（jdk7之前）：制定规则，规范</li><li>默认方法（jdk8）：优化解决<strong>接口升级添加功能</strong>的问题</li><li>静态方法（jdk8）：定义一些可以直接通过接口名调用的方法</li><li><strong>私有方法</strong>（jdk9）：给接口中的<strong>默认方法和静态方法</strong>调用，共有的代码进行抽取复用，并不让外界调用</li><li>常量（jdk7之前）：定义一些可以通过接口名直接方法的值</li></ol></li></ul><h3 id="接口的抽象方法使用"><a href="#接口的抽象方法使用" class="headerlink" title="接口的抽象方法使用"></a>接口的抽象方法使用</h3><ol><li>接口不能够创建对象，没有构造方法。</li><li>定义一个类，实现该接口，并实现该接口中所有的抽象方法。</li><li>创建该接口的实现类的对象，并调用方法来使用。</li></ol><h3 id="接口的默认方法使用"><a href="#接口的默认方法使用" class="headerlink" title="接口的默认方法使用"></a>接口的默认方法使用</h3><ol><li>接口是不能创建对象的，必须使用一个类实现该接口。</li><li>创建实现类的对象才能调用接口中的默认方法。</li><li>在接口的实现类中，可以根据对应的需求，可以选择重写或不重写接口中的默认方法。</li></ol><h3 id="接口的静态方法使用"><a href="#接口的静态方法使用" class="headerlink" title="接口的静态方法使用"></a>接口的静态方法使用</h3><ul><li>只能通过接口名.静态方法(参数列表)直接调用；由于接口的多继承，不能通过实现类对象来调用。</li></ul><h3 id="接口的常量定义和使用"><a href="#接口的常量定义和使用" class="headerlink" title="接口的常量定义和使用"></a>接口的常量定义和使用</h3><ul><li>在接口中的“成员变量”其实就是常量，编译器会自动<code>public static final</code>。</li></ul><h2 id="继承父类并实现多个接口"><a href="#继承父类并实现多个接口" class="headerlink" title="继承父类并实现多个接口"></a>继承父类并实现多个接口</h2><ul><li>注意事项：</li></ul><ol><li>非抽象的子类实现类必须重写所有的抽象方法。</li><li><strong>如果有抽象方法没有实现，那么子类实现类必须是抽象类</strong>。</li><li>如果多个接口中有相同的抽象方法，那么子类实现类只要实现一次即可。</li><li>如果多个接口和抽象父类中有相同的抽象方法，那么子类实现类也只要实现一次即可。</li><li>如果多个接口有相同的抽象方法，并且在父类中有一个同名的普通方法，那么子类实现类可以不重写接口中的抽象方法，也可以根据需求来重写，类的方法优先于接口。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;接口&quot;&gt;&lt;a href=&quot;#接口&quot; class=&quot;headerlink&quot; title=&quot;接口&quot;&gt;&lt;/a&gt;接口&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;接口中的内容特点：&lt;ol&gt;
&lt;li&gt;抽象方法（jdk7之前）：制定规则，规范&lt;/li&gt;
&lt;li&gt;默认方法（jdk8）：优化解决&lt;
      
    
    </summary>
    
      <category term="基础" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="JavaSE" scheme="http://yoursite.com/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>继承、super、this、抽象类</title>
    <link href="http://yoursite.com/2018/06/12/--%E7%BB%A7%E6%89%BF%E3%80%81super%E3%80%81this%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB/"/>
    <id>http://yoursite.com/2018/06/12/--继承、super、this、抽象类/</id>
    <published>2018-06-12T10:46:56.666Z</published>
    <updated>2018-06-20T03:38:47.336Z</updated>
    
    <content type="html"><![CDATA[<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul><li><p>特点：子类拥有父类的所有内容，除了被private和构造方法</p></li><li><p>好处：对相同的内容，进行共性抽取，实现多个类中相同内容的复用,子类可以实现各自的不同功能需求</p></li><li><p>继承中成员变量的访问特点</p><ol><li>直接通过对象去访问，看对象创建语句=左边的内容，是谁就优先使用谁的成员变量，如果没有则向上找</li><li>间接通过对象调用成员方法去访问，调用时，方法属于谁就优先使用谁的成员变量，如果没有则向上找</li></ol></li><li><p>继承中成员方法的访问特点</p><p>在继承中访问成员变量时，new的是谁，就优先使用谁的成员方法，如果没有则向上找</p></li></ul><h3 id="继承中方法的覆盖重写注意事项"><a href="#继承中方法的覆盖重写注意事项" class="headerlink" title="继承中方法的覆盖重写注意事项"></a>继承中方法的覆盖重写注意事项</h3><ul><li>权限：public&gt;protected&gt;(default)不写就是默认&gt;private</li><li>子类方法覆盖父类方法，必须要保证权限大于等于父类权限。</li><li>private的内容不能被继承，所以也就没有重写概念</li><li>方法名和参数类型必须一致</li><li>类型必须小于等于父类的返回值类型（扩展，设计模式6大原则之一：里式替换原则）</li></ul><h3 id="继承中构造方法的访问特点"><a href="#继承中构造方法的访问特点" class="headerlink" title="继承中构造方法的访问特点"></a>继承中构造方法的访问特点</h3><ol><li>创建子类对象时，一定会调用父类的构造方法</li><li>super调用父类的构造方法时，只能在第一个有效语句</li><li>super可以调用父类的有参构造方法。</li><li>super访问父类的构造方法必须在子类的构造方法中的第一句</li></ol><h2 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h2><ol><li>可以在子类的成员方法中，访问父类的成员变量，格式：super.父类成员变量</li><li>可以在子类的成员方法中，访问父类的成员方法，格式：super.父类成员方法名(参数列表)</li><li>可以在子类的构造方法中，访问父类的构造方法，格式：super(参数列表)</li></ol><h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2><ol><li>可以区分当前类中局部变量和成员变量</li><li>可以在本类的成员方法中，调用该类的其他的成员方法(其实在一个类中所有的成员变量和成员方法的调用之前都有this.)</li><li>可以在本类的构造方法中，调用其他的重载构造方法</li></ol><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><ol><li>抽象类不能创建对象，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象</li><li>抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的</li><li>抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类</li><li>抽象类的子类，必须重写抽象父类中所有的抽象方法，否则，编译无法通过而报错。除非该子类也是抽象类。</li></ol><p>抽象类的意义：</p><ul><li>抽象类的意义是对某一些功能添加约束</li><li>重写，我已经实现了自己该有的功能，子类，可以在此基础选择性扩展功能</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;继承&quot;&gt;&lt;a href=&quot;#继承&quot; class=&quot;headerlink&quot; title=&quot;继承&quot;&gt;&lt;/a&gt;继承&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;特点：子类拥有父类的所有内容，除了被private和构造方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;好处：对相同的内容，进行共
      
    
    </summary>
    
      <category term="基础" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="JavaSE" scheme="http://yoursite.com/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList、String、static、工具类</title>
    <link href="http://yoursite.com/2018/06/11/--ArrayList%E3%80%81String%E3%80%81static%E3%80%81%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <id>http://yoursite.com/2018/06/11/--ArrayList、String、static、工具类/</id>
    <published>2018-06-11T12:30:07.867Z</published>
    <updated>2018-06-12T00:38:09.806Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><ul><li><p>好处：</p><p>1、长度可变 </p><p>2、可以进行增删改查 </p><p>3、arraylist可以存放任意<strong>引用数据类型</strong></p></li><li><p>增：</p><p><code>void add(int index, E element)</code> 在此列表中的指定位置插入指定的元素。    </p><p><code>boolean add(E e)</code>将指定的元素追加到此列表的末尾。</p></li><li><p>删：</p><p><code>E remove(int index)</code>删除该列表中指定位置的元素。   </p><p><code>boolean remove(Object o)</code>从列表中删除指定元素的第一个出现（如果存在）。</p></li><li><p>改：</p><p><code>E set(int index, E element)</code> 用指定的元素替换此列表中指定位置的元素。</p></li><li><p>查：</p><p><code>E get(int index)</code> 返回此列表中指定位置的元素。</p></li><li><p>集合长度：</p><p><code>int size()</code> 返回此列表中的元素数。</p></li></ul><h2 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h2><ul><li>String在java中比较特殊，它的对象是保存在方法区的字符串常量池，它的值在创建后不能改变，可以共享；字符串常量池里面的字符串对象，一经创建就不会销毁，只有程序结束时jvm才会释放内存</li></ul><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ol><li><code>String(String original)</code> ：新创建的字符串是参数字符串的副本</li><li><code>public String(char[] value)</code>：通过当前参数中的字符数组来构造新的String</li><li><code>public String(byte[] bytes)</code> ：通过使用平台的默认字符集解码当前参数中的字节数组来构造新的String</li></ol><h3 id="比较的方法"><a href="#比较的方法" class="headerlink" title="比较的方法"></a><strong>比较</strong>的方法</h3><ul><li><code>public boolean equals (Object anObject)</code>：将此字符串与指定对象进行比较。</li></ul><ul><li><code>public boolean equalsIgnoreCase (String anotherString)</code> ：将此字符串与指定对象进行比较，忽略大小写。</li></ul><h3 id="String的获取方法"><a href="#String的获取方法" class="headerlink" title="String的获取方法"></a>String的<strong>获取</strong>方法</h3><p><code>public int length ()</code> ：返回此字符串的长度。</p><p><code>public String concat (String str)</code> ：将指定的字符串连接到该字符串的末尾。</p><p><code>public char charAt (int index)</code> ：返回指定索引处的 char值。</p><p><code>public int indexOf (String str)</code> ：返回指定子字符串第一次出现在该字符串内的索引。</p><p><code>public String substring (int beginIndex)</code>：返回一个子字符串，从beginIndex开始截取字符串到字符串结尾。</p><p><code>public String substring (int beginIndex, int endIndex)</code> ：返回一个子字符串，从beginIndex到endIndex截取字符串。含beginIndex，不含endIndex。</p><h3 id="String的转换方法"><a href="#String的转换方法" class="headerlink" title="String的转换方法"></a>String的<strong>转换</strong>方法</h3><p><code>public char[] toCharArray ()</code> ：将此字符串转换为新的字符数组。</p><p><code>public byte[] getBytes ()</code>：使用平台的默认字符集将该 String编码转换为新的字节数组。</p><p><code>public String replace (CharSequence target, CharSequence replacement)</code>：将与target匹配的字符串使用replacement字符串替换。</p><h3 id="String的分割方法"><a href="#String的分割方法" class="headerlink" title="String的分割方法"></a>String的<strong>分割</strong>方法</h3><p><code>public String[] split(String regex)</code> ：将此字符串按照给定的regex（规则）拆分为字符串数组</p><h2 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h2><ul><li>被static修饰后，只跟类有关，与对象无关，每个对象都可以直接从类中获取该静态变量</li><li>静态代码块：随着类的加载而执行且执行一次，优先于main方法和构造方法的执行。</li></ul><p>静态方法调用的注意事项：</p><ol><li>静态方法可以直接访问类变量（静态变量）和静态方法。</li><li>静态方法不能直接访问普通成员变量或成员方法。静态方法只能访问静态内容，反之，成员方法可以直接访问静态变量或静态方法。</li><li>静态方法中，不能使用this关键字。</li></ol><h2 id="Arrays操作数组的工具类"><a href="#Arrays操作数组的工具类" class="headerlink" title="Arrays操作数组的工具类"></a>Arrays操作数组的工具类</h2><ol><li><code>public static String toString(int[] a)</code>：返回指定数组内容的字符串表示形式。</li><li><code>public static void sort(int[] a)</code> ：对指定的int 型数组按数字升序进行排序。</li></ol><h2 id="Math操作数学方法的工具类"><a href="#Math操作数学方法的工具类" class="headerlink" title="Math操作数学方法的工具类"></a>Math操作数学方法的工具类</h2><ol><li><code>public static double abs(double a)</code>：返回 double 值的绝对值。</li><li><code>public static double ceil(double a)</code> ：向上取整。</li><li><code>public static double floor(double a)</code>：向下取整。</li><li><code>public static long round(double a)</code>：返回最接近参数的 long。(相当于四舍五入方法)</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ArrayList&quot;&gt;&lt;a href=&quot;#ArrayList&quot; class=&quot;headerlink&quot; title=&quot;ArrayList&quot;&gt;&lt;/a&gt;ArrayList&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;好处：&lt;/p&gt;
&lt;p&gt;1、长度可变 &lt;/p&gt;
&lt;p&gt;2、可以进行增
      
    
    </summary>
    
      <category term="基础" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="JavaSE" scheme="http://yoursite.com/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>类与对象、封装、构造方法</title>
    <link href="http://yoursite.com/2018/05/27/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E3%80%81%E5%B0%81%E8%A3%85%E3%80%81%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2018/05/27/类与对象、封装、构造方法/</id>
    <published>2018-05-27T11:58:46.493Z</published>
    <updated>2018-05-27T12:04:48.426Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p>类：一组相关<strong>属性</strong>和<strong>行为</strong>的集合，是一类事物的描述，是<strong>抽象</strong>的</p><p>对象：是类的一个实例，是<strong>具体</strong>的</p><h2 id="对象内存（栈内存、堆内存、方法区）"><a href="#对象内存（栈内存、堆内存、方法区）" class="headerlink" title="对象内存（栈内存、堆内存、方法区）"></a>对象内存（栈内存、堆内存、方法区）</h2><ol><li><p>在方法区中分配空间加载.class文件</p></li><li><p>main方法压栈，创建新对象（如：People p=new People();），在main方法中创建新的对象p来保存地址值；在堆内存中开辟空间，保存People类的属性和<strong>方法地址</strong>，将这块空间的地制值传递给main方法中的变量p</p></li><li><p>通过对象去修改属性，调用方法，只需要通过p中变量地址到堆内存找到那块空间修改属性，再通过<strong>方法地址</strong>到方法区查找方法，并调用</p></li><li><p>找到方法后压栈，执行结束后出栈</p><p><strong>方法地址：实现方法的共享</strong></p></li></ol><h2 id="成员变量-amp-局部变量"><a href="#成员变量-amp-局部变量" class="headerlink" title="成员变量&amp;局部变量"></a>成员变量&amp;局部变量</h2><p>在方法中，如果使用了成员变量与局部变量同名的变量，符合就近原则，直接使用的是局部变量</p><ol><li>定义的位置不同    <ul><li>成员变量：类中方法外    </li><li>局部变量：方法中</li></ul></li><li>作用范围不同 <ul><li>成员变量：整个类中都能用 </li><li>局部变量：只能在定义该变量的方法中</li></ul></li><li>处于内存的位置不同 <ul><li>成员变量：在堆内存中</li><li>局部变量：在栈内存</li></ul></li><li>默认值不同<ul><li>成员变量：有默认值的</li><li>局部变量：没有默认值</li></ul></li><li>生命周期不同<ul><li>成员变量：随着对象的出现而出现，随着对象的销毁而销毁</li><li>局部变量：随着方法的出现而出现，随着方法的销毁而销毁</li></ul></li></ol><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>为了代码安全性</p><ol><li>使用private修饰符</li><li>提供对应属性的getXXX+setXXX方法</li></ol><h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2><p>方法中的形参就是局部变量</p><p>使用this：this.成员变量名，表示的是当前对象的成员变量，可以用来区分成员变量和局部变量</p><p>this：哪个对象调用该方法，那么这个this就表示该对象；可以用来表示调用当前非静态方法的对象的地址值</p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>通过new创建构造方法，创建对象并对属性赋值</p><p>有参构造方法：创建对象并赋值指定的值</p><p>无参构造方法：创建对象并赋值默认初始化值</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;类和对象&quot;&gt;&lt;a href=&quot;#类和对象&quot; class=&quot;headerlink&quot; title=&quot;类和对象&quot;&gt;&lt;/a&gt;类和对象&lt;/h2&gt;&lt;p&gt;类：一组相关&lt;strong&gt;属性&lt;/strong&gt;和&lt;strong&gt;行为&lt;/strong&gt;的集合，是一类事物的描述，是&lt;st
      
    
    </summary>
    
      <category term="基础" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="JavaSE" scheme="http://yoursite.com/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>数组</title>
    <link href="http://yoursite.com/2018/05/27/%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2018/05/27/数组/</id>
    <published>2018-05-27T11:58:44.931Z</published>
    <updated>2018-05-27T11:59:44.623Z</updated>
    
    <content type="html"><![CDATA[<h2 id="java内存分配（简）"><a href="#java内存分配（简）" class="headerlink" title="java内存分配（简）"></a>java内存分配（简）</h2><ul><li><p>栈内存（方法栈）：所有方法在栈内存开辟空间，方法内变量在其空间中再开辟空间；方法中的变量随方法出现而出现，随方法销毁而销毁。</p></li><li><p>堆内存：通过new关键字创建的内容，在堆内存开辟空间都有默认值，</p><p>byte、short、int、long：0</p><p>char：字符空格</p><p>boolean：false</p><p>double：0.0</p><p>引用数据类型：null</p></li><li><p>方法区：字节码文件保存在方法区中</p></li><li><p>寄存器：给cpu使用</p></li><li><p>本地方法栈：jvm在使用操作系统功能时使用</p></li></ul><h2 id="数组异常"><a href="#数组异常" class="headerlink" title="数组异常"></a>数组异常</h2><ul><li><p>ArrayIndexOutOfBoundersException：数组索引越界异常</p><p>注意：数组长度固定，最大索引值是array.length-1</p></li><li><p>NullPointerException：空指针异常</p></li></ul><p><strong>数组作为方法参数传递的是数组地址</strong></p><p><strong>数组作为返回值类型返回的是数组地址</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;java内存分配（简）&quot;&gt;&lt;a href=&quot;#java内存分配（简）&quot; class=&quot;headerlink&quot; title=&quot;java内存分配（简）&quot;&gt;&lt;/a&gt;java内存分配（简）&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;栈内存（方法栈）：所有方法在栈内存开辟空间，方法内
      
    
    </summary>
    
      <category term="基础" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="JavaSE" scheme="http://yoursite.com/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>流程控制、方法</title>
    <link href="http://yoursite.com/2018/05/23/--%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E3%80%81%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2018/05/23/--流程控制、方法/</id>
    <published>2018-05-23T07:50:56.924Z</published>
    <updated>2018-05-24T07:22:34.840Z</updated>
    
    <content type="html"><![CDATA[<h2 id="switch语句case穿透"><a href="#switch语句case穿透" class="headerlink" title="switch语句case穿透"></a>switch语句case穿透</h2><ol><li>switch(表达式)：进行选择判断的数据类型只能是byte、short、int、char、menu、String</li><li>case穿透：匹配一个case后，执行语句体，没有break继续向下执行，直到遇到break跳出或switch语句结束</li></ol><h2 id="三种循环区别"><a href="#三种循环区别" class="headerlink" title="三种循环区别"></a>三种循环区别</h2><ol><li>循环条件都不满足时，只有do-while一定会执行一次</li><li>for循环的变量定义在for内部，for循环以外不能用</li><li>while和do-while的循环变量可以一直使用</li></ol><h2 id="break-amp-continue"><a href="#break-amp-continue" class="headerlink" title="break&amp;continue"></a>break&amp;continue</h2><ul><li>break：结束switch语句、结束循环（<strong>只能在循环与switch中使用</strong>）</li><li>continue：跳过本次循环，继续下一次循环</li></ul><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ol><li>明确返回值类型</li><li>明确参数列表</li><li>方法在执行时必须压栈到栈内存中，在栈内存中jvm只执行内存栈顶的方法</li><li>定义在类中方法体外</li><li>return：结束方法，跟是否返回方法的调用处无关，只要方法结束一定返回方法调用处；一个方法可以有多个return，但只有一个return被调用。</li></ol><h2 id="方法调用三种方式"><a href="#方法调用三种方式" class="headerlink" title="方法调用三种方式"></a>方法调用三种方式</h2><ul><li>直接调用：方法名(参数列表)</li><li>赋值调用：数据类型 变量名=方法名(参数列表)</li><li>打印输出：System.out.println(方法名(参数列表))</li></ul><p><strong>直接调用可以调用任意方法，赋值调用和打印输出只能调用有返回值的方法</strong></p><h2 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h2><ol><li>同一个类中</li><li>同一个方法名</li><li>参数列表不同：参数列表的个数，数据类型，参数的顺序（<strong>与修饰符和返回值类型无关</strong>）</li></ol><p>作用：只要记忆一个方法，就可以实现对应的功能</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;switch语句case穿透&quot;&gt;&lt;a href=&quot;#switch语句case穿透&quot; class=&quot;headerlink&quot; title=&quot;switch语句case穿透&quot;&gt;&lt;/a&gt;switch语句case穿透&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;switch(表达式)：进行选择
      
    
    </summary>
    
      <category term="基础" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="JavaSE" scheme="http://yoursite.com/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>编译运行、数据类型</title>
    <link href="http://yoursite.com/2018/05/21/--%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://yoursite.com/2018/05/21/--编译运行、数据类型/</id>
    <published>2018-05-21T13:43:33.986Z</published>
    <updated>2018-05-22T09:02:48.992Z</updated>
    
    <content type="html"><![CDATA[<h2 id="java开发环境"><a href="#java开发环境" class="headerlink" title="java开发环境"></a>java开发环境</h2><ol><li>jvm：支持java程序运行的程序，实现java的跨平台，jvm不跨</li><li>jre：jvm+jvm运行核心类库</li><li>jdk：jre+java开发包</li></ol><h2 id="编译和运行"><a href="#编译和运行" class="headerlink" title="编译和运行"></a>编译和运行</h2><ul><li>编译：javac.exe启动编译器，将源文件（.java）编译为字节码文件（.class）</li><li>运行：java.exe启动解释器，将.class文件翻译为机器码文件，放入jvm运行</li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ol><li><p>基本数据类型：</p><p>整数型：byte（1）-128——127</p><p>​          short（2）</p><p>​          int（4）<strong>默认</strong>   </p><p>​              long（8）</p><p>浮点型：float：（4）</p><p>​              double（8）<strong>默认</strong></p><p> 字符型：char（2）</p><p>布尔型：boolean（1）</p></li><li><p>引用数据类型：类，数组，接口</p></li></ol><h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><p>转换顺序由小转大：byte、short、char—-&gt;int—-&gt;float—-&gt;double</p><p>强转由大转小：将前面没有意义的字节数去掉，小数点的强转将小数点后面数去掉</p><p>字符的转换：ASCII码：0（48）、A（65）、a（97）</p><h2 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h2><p>数据类型 变量名=表达式1?表达式2:表达式3；</p><p>数据类型与表达式2:表达式3必须一致</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;java开发环境&quot;&gt;&lt;a href=&quot;#java开发环境&quot; class=&quot;headerlink&quot; title=&quot;java开发环境&quot;&gt;&lt;/a&gt;java开发环境&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;jvm：支持java程序运行的程序，实现java的跨平台，jvm不跨&lt;/li&gt;

      
    
    </summary>
    
      <category term="基础" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="JavaSE" scheme="http://yoursite.com/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>JSP简介</title>
    <link href="http://yoursite.com/2018/04/08/jsp%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2018/04/08/jsp简介/</id>
    <published>2018-04-08T11:36:11.556Z</published>
    <updated>2018-04-08T11:44:16.128Z</updated>
    
    <content type="html"><![CDATA[<h2 id="jsp运行原理"><a href="#jsp运行原理" class="headerlink" title="jsp运行原理"></a>jsp运行原理</h2><p>　　jsp实质就是servlet（jsp文件转换servlet文件(.java)编译class文件(.class)执行servlet实例），第一次被访问时会被web容器翻译成servlet再执行。</p><h2 id="jsp三大指令"><a href="#jsp三大指令" class="headerlink" title="jsp三大指令"></a>jsp三大指令</h2><p>1、page指令属性最多，默认就行<br>2、include指令：将一个jsp页面包含到另一个jsp页面<br>　　格式：&lt;%@ include file=”被包含的文件地址”%&gt;<br>3、taglib指令：引入标签库（jstl）<br>　　格式：&lt;%@ taglib uri=”标签库地址” prefix=”前缀”%&gt;</p><h2 id="jsp内置9大隐式对象"><a href="#jsp内置9大隐式对象" class="headerlink" title="jsp内置9大隐式对象"></a><strong>jsp内置9大隐式对象</strong></h2><p><strong>out：用于页面输出，out.write()</strong><br>request：得到用户请求信息<br>response：服务器向客户端的回应信息<br>config：服务器配置<br>session：保存用户的信息<br>application：所有用户共享信息<br>page：当前页面转换后的servlet类的实例<br><strong>pageContext：jsp的页面容器（域对象）</strong><br>exception：异常，在错误页面起作用</p><h2 id="4大域总结"><a href="#4大域总结" class="headerlink" title="4大域总结"></a><strong>4大域总结</strong></h2><p><strong>page域：当前jsp页面范围<br>request域：一次请求<br>session域：一次会话<br>application域：整个web应用</strong></p><p>findAttribute(String name)——<strong>依次从pageContext域，request域，session域，application域中获取属性，获取完将不再向下获取</strong>。</p><p>通过pageContext可获得其他八大隐式对象</p><h2 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h2><p>　　嵌入jsp页面内部，代替jsp页面编写，最主要作用从域中取数据<br>　　jsp脚本：&lt;%=request.getAttribute(name)%&gt;<br>　　EL表达式：${requestScorp.name}</p><hr><p>EL获得pageContext域中的值：<code>${pageScope.key}</code><br>EL获得request域中的值：<code>${requestScope.key}</code><br>EL获得session域中的值：<code>${sessionScopre.key}</code><br>EL获得application域中的值：<code>${applicationScope.key}</code></p><h2 id="EL内置11个对象"><a href="#EL内置11个对象" class="headerlink" title="EL内置11个对象"></a><strong>EL内置11个对象</strong></h2><p>　　作用域：pageScope（page域）、requestScope（request作用域）、sessionScope（session域）、applicationScope（application域）<br>　　请求参数：param（获得一个参数）、paramValues（获得一组参数）<br>　　请求头：header（获得一个请求头）、headerValues（获得一组请求头）<br>　　JSP上下文象：pageContext<br>　　全局初始化参数：initParam<br>　　cookie：cookie</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;jsp运行原理&quot;&gt;&lt;a href=&quot;#jsp运行原理&quot; class=&quot;headerlink&quot; title=&quot;jsp运行原理&quot;&gt;&lt;/a&gt;jsp运行原理&lt;/h2&gt;&lt;p&gt;　　jsp实质就是servlet（jsp文件转换servlet文件(.java)编译class文件(
      
    
    </summary>
    
      <category term="JavaWeb" scheme="http://yoursite.com/categories/JavaWeb/"/>
    
    
      <category term="JavaWeb" scheme="http://yoursite.com/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>Cookie&amp;Session</title>
    <link href="http://yoursite.com/2018/03/25/Cookie&amp;Session/"/>
    <id>http://yoursite.com/2018/03/25/Cookie&amp;Session/</id>
    <published>2018-03-25T08:59:34.572Z</published>
    <updated>2018-03-25T09:38:41.087Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>　　cookie是将数据存储到客户端。<br>　　服务器端向客户端发送一个cookie：<br>　　1、创建cookie：<br>　　<code>Cookie cookie=new Cookie(name,value);</code><br>　　<code>cookie.setMaxAge(秒);</code><br>　　 <code>cookie.setPath();</code><br>　　2、发送cookie：<br>　　<code>response.addCookie(Cookie cookie);</code></p><hr><p>　　服务器端接受客户端携带的Cookie：<br>　  <code>Cookie[] cookies=request.getCookies();</code><br>　<code>for(Cookie cookie:cookies){</code><br>　　　　<code>if(cookie.getName().equal(cookieName)){</code><br>　　　　　<code>String　cookieValue=cookie.getValue();</code><br>　　　<code>}</code><br>　<code>}</code></p><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>　　在服务端为每个客户端创建一块自己的内存空间，客户端携带一个标识ID去寻找自己的内存空间。<br>　　1、获得session对象：<br>　　<code>request.getSession();</code><br>　　2、向session中存取数据(域对象)：<br>　　<code>session.setAttribute(String name,Object obj);</code><br>　　<code>session.getAttribute(String name);</code><br>　　<code>session.removeAttribute(String name);</code><br>　　3、session生命周期<br>　　创建：第一次执行request.getSession();<br>　　销毁：服务器关闭、session失效、手动session.invalidate();<br>　　作用范围：默认一次会话中</p><p>　　</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Cookie&quot;&gt;&lt;a href=&quot;#Cookie&quot; class=&quot;headerlink&quot; title=&quot;Cookie&quot;&gt;&lt;/a&gt;Cookie&lt;/h2&gt;&lt;p&gt;　　cookie是将数据存储到客户端。&lt;br&gt;　　服务器端向客户端发送一个cookie：&lt;br&gt;　　1、创建
      
    
    </summary>
    
      <category term="JavaWeb" scheme="http://yoursite.com/categories/JavaWeb/"/>
    
    
      <category term="JavaWeb" scheme="http://yoursite.com/tags/JavaWeb/"/>
    
  </entry>
  
</feed>
